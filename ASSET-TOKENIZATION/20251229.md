# KYC機能の実装とMyTokenSaleの拡張

**日付**: 2025年12月29日
**学習内容**: KycContractの実装、MyTokenSaleへのKYC機能統合、包括的なKYCテストの追加

## 1. KYC（Know Your Customer）とは

### 1.1 KYCの目的

**KYC（Know Your Customer）**は、金融取引において顧客の本人確認を行うプロセスです。トークンセールにおいても、規制遵守のためにKYCが必要とされることがあります。

**主な目的**:
- マネーロンダリング防止（AML: Anti-Money Laundering）
- テロ資金供与対策（CTF: Counter-Terrorist Financing）
- 規制要件の遵守
- 投資家保護

### 1.2 ブロックチェーンにおけるKYC

ブロックチェーンは本来匿名性が高いため、KYCの実装には特別な考慮が必要です：

**アプローチ**:
1. **オフチェーンKYC**: 実際の本人確認はオフチェーンで実施
2. **オンチェーン承認**: 承認されたアドレスのみブロックチェーンに記録
3. **プライバシー保護**: 個人情報はブロックチェーンに保存しない

## 2. KycContractの実装

### 2.1 コントラクトの全体像

```solidity
// SPDX-License-Identifier: MIT
// Compatible with OpenZeppelin Contracts ^5.5.0
pragma solidity ^0.8.27;

import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title KycContract
 * @dev KYC (Know Your Customer) contract for managing approved addresses
 * Only KYC-approved addresses can participate in the token sale
 */
contract KycContract is Ownable {
    mapping(address => bool) private _kycCompleted;

    event KycCompleted(address indexed account);
    event KycRevoked(address indexed account);

    constructor() Ownable(msg.sender) {}

    /**
     * @dev Approve an address for KYC
     * @param _addr Address to approve
     */
    function setKycCompleted(address _addr) public onlyOwner {
        require(_addr != address(0), "KycContract: address is the zero address");
        _kycCompleted[_addr] = true;
        emit KycCompleted(_addr);
    }

    /**
     * @dev Revoke KYC approval for an address
     * @param _addr Address to revoke
     */
    function setKycRevoked(address _addr) public onlyOwner {
        require(_addr != address(0), "KycContract: address is the zero address");
        _kycCompleted[_addr] = false;
        emit KycRevoked(_addr);
    }

    /**
     * @dev Check if an address is KYC approved
     * @param _addr Address to check
     * @return bool true if approved, false otherwise
     */
    function kycCompleted(address _addr) public view returns(bool) {
        return _kycCompleted[_addr];
    }
}
```

### 2.2 コントラクトの詳細解説

#### 継承関係

```
KycContract
    ↓ is
Ownable
    ↓ is
Context
```

**Ownableを継承する理由**:
- KYC承認/取り消しは管理者のみが実行可能
- アクセス制御の標準実装を利用
- セキュリティのベストプラクティス

#### 状態変数とイベント

```solidity
mapping(address => bool) private _kycCompleted;

event KycCompleted(address indexed account);
event KycRevoked(address indexed account);
```

**_kycCompletedマッピング**:
- アドレスごとのKYCステータスを管理
- `private`指定でカプセル化
- `kycCompleted()`関数経由でのみアクセス可能

**イベントの重要性**:
- オフチェーンアプリケーションでの監視
- 透明性の確保
- トランザクション履歴の追跡

#### コンストラクタ

```solidity
constructor() Ownable(msg.sender) {}
```

**OpenZeppelin Contracts v5.0の変更点**:
- Ownableのコンストラクタが引数を要求
- `msg.sender`を明示的にオーナーとして設定
- 以前のバージョンからの重要な変更

#### setKycCompleted関数

```solidity
function setKycCompleted(address _addr) public onlyOwner {
    require(_addr != address(0), "KycContract: address is the zero address");
    _kycCompleted[_addr] = true;
    emit KycCompleted(_addr);
}
```

**機能**:
1. オーナーのみが実行可能（`onlyOwner`修飾子）
2. ゼロアドレスのチェック
3. KYCステータスを`true`に設定
4. イベントを発火

**使用例**:
```solidity
// オフチェーンでKYC完了後
kycContract.setKycCompleted(0x1234...);
```

#### setKycRevoked関数

```solidity
function setKycRevoked(address _addr) public onlyOwner {
    require(_addr != address(0), "KycContract: address is the zero address");
    _kycCompleted[_addr] = false;
    emit KycRevoked(_addr);
}
```

**機能**:
- KYC承認を取り消す
- 不正が発覚した場合などに使用
- 既存の承認を無効化

**重要な使用ケース**:
- 詐欺の疑いがある場合
- 規制違反が判明した場合
- ユーザーからの取り消し要求

#### kycCompleted関数

```solidity
function kycCompleted(address _addr) public view returns(bool) {
    return _kycCompleted[_addr];
}
```

**機能**:
- アドレスのKYCステータスを照会
- `view`関数なのでガス不要
- 他のコントラクトから呼び出し可能

## 3. MyTokenSaleへのKYC機能統合

### 3.1 更新されたMyTokenSale

```solidity
// SPDX-License-Identifier: MIT
// Compatible with OpenZeppelin Contracts ^5.5.0
pragma solidity ^0.8.27;

import "./Crowdsale.sol";
import "./KycContract.sol";

contract MyTokenSale is Crowdsale {

    KycContract public kycContract;

    constructor(
        uint256 rate,    // rate in TKNbits
        address payable wallet,
        IERC20 token,
        KycContract _kycContract
    )
        Crowdsale(rate, wallet, token)
    {
        kycContract = _kycContract;

    }

    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view override {
        super._preValidatePurchase(beneficiary, weiAmount);
        require(kycContract.kycCompleted(msg.sender), "MyTokenSale: beneficiary not KYC approved");
    }
}
```

### 3.2 変更点の詳細解説

#### KycContractのインポートと保存

```solidity
import "./KycContract.sol";

KycContract public kycContract;
```

**設計の選択**:
- `public`指定で自動的にgetter関数を生成
- 外部からKycContractのアドレスを確認可能
- テストやフロントエンドから参照しやすい

#### コンストラクタの拡張

```solidity
constructor(
    uint256 rate,
    address payable wallet,
    IERC20 token,
    KycContract _kycContract  // 新しいパラメータ
)
    Crowdsale(rate, wallet, token)
{
    kycContract = _kycContract;
}
```

**重要な変更**:
1. `public`修飾子を削除
   - Solidity 0.8.27では警告が出る
   - コンストラクタに可視性修飾子は不要

2. `_kycContract`パラメータの追加
   - KycContractのインスタンスを受け取る
   - デプロイ時にKycContractを指定

**デプロイの流れ**:
```solidity
// 1. KycContractをデプロイ
KycContract kyc = new KycContract();

// 2. MyTokenSaleをデプロイ（KycContractを渡す）
MyTokenSale sale = new MyTokenSale(1, wallet, token, kyc);
```

#### _preValidatePurchase関数のオーバーライド

```solidity
function _preValidatePurchase(address beneficiary, uint256 weiAmount)
    internal
    view
    override
{
    super._preValidatePurchase(beneficiary, weiAmount);
    require(kycContract.kycCompleted(msg.sender), "MyTokenSale: beneficiary not KYC approved");
}
```

**実装の詳細**:

1. **super呼び出し**:
   ```solidity
   super._preValidatePurchase(beneficiary, weiAmount);
   ```
   - 親コントラクト（Crowdsale）の検証を実行
   - ゼロアドレスチェック
   - ゼロweiチェック

2. **KYCチェック**:
   ```solidity
   require(kycContract.kycCompleted(msg.sender), "MyTokenSale: beneficiary not KYC approved");
   ```
   - `msg.sender`がKYC承認済みかチェック
   - 未承認の場合はトランザクションをリバート

**なぜmsg.senderをチェックするのか？**:
- `beneficiary`は受取人（トークンを受け取るアドレス）
- `msg.sender`は送信者（実際に購入する人）
- KYC承認が必要なのは実際に購入する人

**セキュリティの考慮事項**:
```solidity
// ケース1: 自分用に購入
buyTokens(msg.sender)
// → msg.sender = beneficiary = 購入者

// ケース2: 他人のために購入
buyTokens(otherAddress)
// → msg.sender = 購入者（KYC必要）
// → beneficiary = 受取人
```

## 4. 包括的なテストの実装

### 4.1 テストの追加項目

12月29日に追加された主なテストケース：

```solidity
// 1. KYC承認されたアドレスはトークン購入が可能
function testBuyTokens() public {
    // buyer1をKYC承認
    kycContract.setKycCompleted(buyer1);

    vm.deal(buyer1, 1 ether);
    vm.prank(buyer1);
    tokenSale.buyTokens{value: weiAmount}(buyer1);

    assertEq(token.balanceOf(buyer1), expectedTokens);
}

// 2. KYC未承認のアドレスはトークン購入不可
function testCannotBuyWithoutKyc() public {
    vm.deal(buyer1, 1 ether);
    vm.prank(buyer1);
    vm.expectRevert("MyTokenSale: beneficiary not KYC approved");
    tokenSale.buyTokens{value: weiAmount}(buyer1);
}

// 3. KYC承認を取り消すと購入不可になる
function testRevokeKyc() public {
    // 最初はKYC承認
    kycContract.setKycCompleted(buyer1);

    // 購入可能
    vm.deal(buyer1, 1 ether);
    vm.prank(buyer1);
    tokenSale.buyTokens{value: weiAmount}(buyer1);

    // KYCを取り消す
    kycContract.setKycRevoked(buyer1);

    // 購入不可になる
    vm.deal(buyer1, 1 ether);
    vm.prank(buyer1);
    vm.expectRevert("MyTokenSale: beneficiary not KYC approved");
    tokenSale.buyTokens{value: weiAmount}(buyer1);
}

// 4. KYCコントラクトのアドレスを取得できる
function testGetKycContract() public view {
    assertEq(address(tokenSale.kycContract()), address(kycContract));
}
```

### 4.2 テストの詳細解説

#### KYC承認後の購入テスト

```solidity
function testBuyTokens() public {
    uint256 weiAmount = 100;
    uint256 expectedTokens = weiAmount * RATE;

    // buyer1をKYC承認
    kycContract.setKycCompleted(buyer1);

    // buyer1の初期残高を確認
    uint256 balanceBefore = token.balanceOf(buyer1);
    assertEq(balanceBefore, 0);

    // イベントが発火されることを期待
    vm.expectEmit(true, true, false, true);
    emit TokensPurchased(buyer1, buyer1, weiAmount, expectedTokens);

    // buyer1がトークンを購入
    vm.deal(buyer1, 1 ether);
    vm.prank(buyer1);
    tokenSale.buyTokens{value: weiAmount}(buyer1);

    // buyer1の残高を確認
    uint256 balanceAfter = token.balanceOf(buyer1);
    assertEq(balanceAfter, expectedTokens);
}
```

**テストの流れ**:
1. KYC承認（`setKycCompleted`）
2. 初期残高の確認
3. イベント発火の期待値設定
4. トークン購入の実行
5. 購入後の残高確認

**Foundryの便利な機能**:
- `vm.deal()`: テスト用のETHを付与
- `vm.prank()`: 特定のアドレスとしてトランザクション実行
- `vm.expectEmit()`: イベント発火の検証

#### KYC未承認での購入失敗テスト

```solidity
function testCannotBuyWithoutKyc() public {
    uint256 weiAmount = 100;

    vm.deal(buyer1, 1 ether);
    vm.prank(buyer1);
    vm.expectRevert("MyTokenSale: beneficiary not KYC approved");
    tokenSale.buyTokens{value: weiAmount}(buyer1);
}
```

**重要なポイント**:
- KYC承認を**行わない**
- `vm.expectRevert()`で特定のエラーメッセージを期待
- トランザクションが正しくリバートすることを確認

**セキュリティテストの重要性**:
- 不正なアクセスがブロックされることを確認
- アクセス制御が正しく機能することを検証

#### KYC取り消しテスト

```solidity
function testRevokeKyc() public {
    uint256 weiAmount = 100;

    // buyer1をKYC承認
    kycContract.setKycCompleted(buyer1);

    // buyer1が購入可能であることを確認
    vm.deal(buyer1, 1 ether);
    vm.prank(buyer1);
    tokenSale.buyTokens{value: weiAmount}(buyer1);
    assertEq(token.balanceOf(buyer1), weiAmount * RATE);

    // KYCを取り消す
    kycContract.setKycRevoked(buyer1);

    // buyer1は購入不可になる
    vm.deal(buyer1, 1 ether);
    vm.prank(buyer1);
    vm.expectRevert("MyTokenSale: beneficiary not KYC approved");
    tokenSale.buyTokens{value: weiAmount}(buyer1);
}
```

**テストシナリオ**:
1. KYC承認 → 購入成功
2. KYC取り消し
3. 再度購入 → 失敗

**実際の使用ケース**:
- 詐欺が発覚した場合の緊急対応
- 規制違反への対処
- 動的なアクセス制御

#### receive関数経由の購入テスト

```solidity
function testBuyTokensViaReceive() public {
    uint256 weiAmount = 50;
    uint256 expectedTokens = weiAmount * RATE;

    // buyer2をKYC承認
    kycContract.setKycCompleted(buyer2);

    // buyer2に1 ETHを付与
    vm.deal(buyer2, 1 ether);

    // buyer2の初期残高を確認
    uint256 balanceBefore = token.balanceOf(buyer2);
    assertEq(balanceBefore, 0);

    // buyer2がETHを直接送信（receive関数が呼ばれる）
    vm.prank(buyer2);
    (bool success, ) = address(tokenSale).call{value: weiAmount}("");
    require(success, "ETH transfer failed");

    // buyer2の残高を確認
    uint256 balanceAfter = token.balanceOf(buyer2);
    assertEq(balanceAfter, expectedTokens);
}
```

**テストの目的**:
- 直接ETH送信でも購入できることを確認
- receive関数経由でもKYCチェックが機能することを検証
- ユーザビリティテスト

## 5. デプロイスクリプトの更新

### 5.1 更新されたDeploy.s.sol

```solidity
// KycContractをデプロイ
KycContract kycContract = new KycContract();

console.log("\n=== KycContract Deployed ===");
console.log("Contract address:", address(kycContract));
console.log("Owner:", kycContract.owner());

// MyTokenSaleをデプロイ（KycContractを含む）
MyTokenSale tokenSale = new MyTokenSale(
    1,  // rate: 1 wei = 1 token
    payable(deployer),  // wallet address
    IERC20(address(token)),
    kycContract  // KycContractを渡す
);

console.log("\n=== MyTokenSale Deployed ===");
console.log("Contract address:", address(tokenSale));
console.log("Rate:", tokenSale.rate());
console.log("Wallet:", tokenSale.wallet());
console.log("Token:", address(tokenSale.token()));
console.log("KYC Contract:", address(tokenSale.kycContract()));
```

### 5.2 デプロイフロー

**正しいデプロイ順序**:
1. MyTokenをデプロイ
2. **KycContractをデプロイ**（新規）
3. MyTokenSaleをデプロイ（KycContractのアドレスを渡す）
4. トークンをMyTokenSaleに転送

**依存関係**:
```
MyToken ← MyTokenSale ← KycContract
  ↓         ↓
  └─────────┘
```

## 6. テスト実行結果

### 6.1 全テストの成功

```bash
$ forge test

Ran 6 tests for test/MyToken.t.sol:MyTokenTest
[PASS] testApproveAndTransferFrom() (gas: 52824)
[PASS] testFuzzTransfer(address,uint256) (runs: 256, μ: 38968, ~: 40033)
[PASS] testInitialSupply() (gas: 7592)
[PASS] testRevertTransferInsufficientBalance() (gas: 15556)
[PASS] testTransfer() (gas: 39699)
[PASS] testTransferEvent() (gas: 42167)
Suite result: ok. 6 passed; 0 failed; 0 skipped

Ran 13 tests for test/MyTokenSale.t.sol:MyTokenSaleTest
[PASS] testAllTokensInTokenSale() (gas: 12784)
[PASS] testBuyTokens() (gas: 159615)
[PASS] testBuyTokensViaReceive() (gas: 156544)
[PASS] testCannotBuyToZeroAddress() (gas: 23496)
[PASS] testCannotBuyWithZeroWei() (gas: 47219)
[PASS] testCannotBuyWithoutKyc() (gas: 31258)
[PASS] testDeployerHasNoTokens() (gas: 7847)
[PASS] testEthForwardedToWallet() (gas: 155091)
[PASS] testFuzzBuyTokens(uint256) (runs: 256, μ: 156747, ~: 156747)
[PASS] testGetKycContract() (gas: 9893)
[PASS] testMultipleBuyers() (gas: 229059)
[PASS] testRevokeKyc() (gas: 151870)
[PASS] testWeiRaisedUpdated() (gas: 226979)
Suite result: ok. 13 passed; 0 failed; 0 skipped

Ran 2 test suites: 19 tests passed, 0 failed, 0 skipped
```

### 6.2 カバレッジの向上

**追加されたテストケース**:
- KYC承認後の購入: ✅
- KYC未承認での購入失敗: ✅
- KYC取り消し後の購入失敗: ✅
- receive関数経由の購入: ✅
- KycContract参照の取得: ✅

**テストカバレッジ**:
- 正常系（Happy Path）
- 異常系（エラーケース）
- エッジケース（境界値）
- セキュリティテスト

## 7. 学んだこと

### 7.1 KYCの実装パターン

**オンチェーンKYCの設計原則**:
1. **最小限の情報**: 個人情報はオフチェーンで管理
2. **アクセス制御**: Ownableパターンで管理者のみが承認
3. **柔軟性**: 承認の取り消しが可能
4. **透明性**: イベントで全ての変更を記録
5. **モジュラー設計**: KYCロジックを分離したコントラクト

### 7.2 継承とオーバーライド

**_preValidatePurchase関数のオーバーライド**:
```solidity
function _preValidatePurchase(address beneficiary, uint256 weiAmount)
    internal
    view
    override
{
    super._preValidatePurchase(beneficiary, weiAmount);
    // 追加の検証ロジック
}
```

**このパターンの利点**:
- 親の検証ロジックを維持
- 追加の検証を簡単に追加
- 疎結合で拡張可能

### 7.3 Solidity 0.8.27での変更点

**コンストラクタの可視性**:
```solidity
// ❌ 警告が出る
constructor() public Ownable(msg.sender) {}

// ✅ 正しい
constructor() Ownable(msg.sender) {}
```

**OpenZeppelin Contracts v5.0**:
```solidity
// v4.x
constructor() {}
// Ownableが自動的にmsg.senderをオーナーに設定

// v5.0
constructor() Ownable(msg.sender) {}
// 明示的にオーナーを指定
```

### 7.4 セキュリティのベストプラクティス

**アクセス制御の実装**:
1. **Ownable**: 管理者機能に使用
2. **KYCチェック**: トークン購入に使用
3. **検証関数**: 各ステップで入力を検証
4. **イベント**: 全ての重要な操作を記録

**防御的プログラミング**:
```solidity
require(_addr != address(0), "address is the zero address");
require(kycContract.kycCompleted(msg.sender), "not KYC approved");
```

## 8. まとめ

### 8.1 実装内容

**12月29日の主な追加機能**:
1. ✅ KycContract.solの新規作成
2. ✅ MyTokenSaleへのKYC機能統合
3. ✅ 包括的なKYCテストの追加
4. ✅ デプロイスクリプトの更新

### 8.2 技術スタック

**使用技術**:
- Solidity 0.8.27
- OpenZeppelin Contracts v5.5.0
- Foundry（テスト・デプロイ）
- Anvil（ローカルノード）

### 8.3 次のステップ

**今後の拡張案**:
1. **タイムベースのセール**: 開始・終了時刻の設定
2. **キャップ機能**: 最大販売数量の制限
3. **ホワイトリスト**: KYC承認者のみ購入可能（実装済み）
4. **段階的価格**: 販売フェーズに応じた価格設定
5. **リファンド機能**: 目標未達成時の返金

この実装により、規制要件に準拠したトークンセールシステムの基礎が完成しました。KYCコントラクトの分離により、他のプロジェクトでも再利用可能なモジュラーな設計となっています。
