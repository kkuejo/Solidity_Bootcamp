# レガシーCrowdsaleコントラクトの現代化：Solidity 0.8.27への移行

**日付**: 2025年12月26日
**学習内容**: OpenZeppelin Crowdsaleコントラクトの歴史的背景、Solidity 0.6.1から0.8.27への移行、スマートコントラクトアーキテクチャの単一責任原則

## 1. OpenZeppelin Crowdsaleコントラクトの歴史

### 1.1 Crowdsaleコントラクトとは

**Crowdsale**は、OpenZeppelinが提供していたトークンセール（ICO: Initial Coin Offering）を実装するための基盤コントラクトです。

**主な機能**:
- ETHを受け取ってトークンを販売
- レート設定（1 ETH = X トークン）
- 資金の転送先ウォレット設定
- 拡張可能な設計（キャップ付き、時間制限付き等）

**2017年のICOブーム**:
- 2017年はICO（Initial Coin Offering）の全盛期
- 多くのプロジェクトがトークンセールで資金調達
- Crowdsaleコントラクトは非常に需要が高かった

### 1.2 OpenZeppelin v3.0での削除

**2020年の変化**:
OpenZeppelinは2020年にリリースしたバージョン3.0でCrowdsaleコントラクトを削除しました。

**削除された理由**:
1. **使用頻度の低下**: 2017年のICOブームが終わり、2020年にはクラウドセールの需要が大幅に減少
2. **Solidity 0.6への移行の複雑さ**: コントラクトをSolidity 0.6に移行する作業が複雑
3. **戦略的な方向転換**: OpenZeppelinは純粋なERC標準の実装に注力し、アプリケーション特有のコントラクトのメンテナンスを終了

**利用可能なバージョン**:
- Crowdsaleコントラクトは**OpenZeppelin Contracts v2.5**で引き続き利用可能
- セキュリティ問題に対するサポートは継続
- しかし、v3.0以降には含まれていない

### 1.3 なぜ今でもCrowdsaleが必要なのか？

**学習・教育目的**:
- トークンセールのメカニズムを理解する
- コントラクト間の相互作用を学ぶ
- スマートコントラクトのアーキテクチャパターンを習得

**実用的な用途**:
- オークションのような複雑なセールは不要
- シンプルな定価販売で十分な場合が多い
- プライベートセールやプレセール

**アーキテクチャの利点**:
- **関心の分離（Separation of Concerns）**: トークンロジックとセールロジックを分離
- **単一責任原則（Single Responsibility Principle）**: 各コントラクトは1つのことだけを行う
- **拡張性**: トークンコントラクトに機能を詰め込まない

## 2. Solidity バージョン間の主要な変更点

### 2.1 Solidity 0.6.1 → 0.8.27の主な違い

#### SafeMathの廃止

**Solidity 0.6.1（旧バージョン）**:
```solidity
import "@openzeppelin/contracts/math/SafeMath.sol";

contract Example {
    using SafeMath for uint256;

    function add(uint256 a, uint256 b) public pure returns (uint256) {
        return a.add(b);  // SafeMathを使用
    }
}
```

**Solidity 0.8.0以降（現在）**:
```solidity
contract Example {
    // SafeMathは不要

    function add(uint256 a, uint256 b) public pure returns (uint256) {
        return a + b;  // 組み込みのオーバーフロー保護
    }
}
```

**理由**:
- Solidity 0.8.0から算術演算に**組み込みのオーバーフロー/アンダーフロー保護**が追加
- `unchecked`ブロックで明示的に保護を無効化可能
- ガス効率の向上とコードの簡潔化

#### コンストラクタの可視性

**Solidity 0.6.1（旧バージョン）**:
```solidity
constructor(uint256 value) public {
    // ...
}
```

**Solidity 0.8.0以降（現在）**:
```solidity
constructor(uint256 value) {
    // publicキーワードは不要（常にpublic）
}
```

#### fallback関数とreceive関数の分離

**Solidity 0.6.0以前**:
```solidity
function() external payable {
    // ETHを受信
}
```

**Solidity 0.6.0以降**:
```solidity
// ETH受信専用
receive() external payable {
    buyTokens(_msgSender());
}

// データ付きコール用
fallback() external payable {
    // ...
}
```

**理由**:
- ETH受信と通常のfallbackを明確に分離
- セキュリティの向上
- コードの意図が明確化

#### transfer vs call

**Solidity 0.6.1（旧バージョン）**:
```solidity
function _forwardFunds() internal {
    _wallet.transfer(msg.value);  // 2300 gasの制限
}
```

**Solidity 0.8.0以降（推奨）**:
```solidity
function _forwardFunds() internal virtual {
    (bool success, ) = _wallet.call{value: msg.value}("");
    require(success, "Crowdsale: failed to forward funds");
}
```

**理由**:
- `transfer()`は2300 gasに制限されており、複雑なコントラクトでは失敗する可能性
- `call()`はより柔軟で、将来のガス価格変更にも対応
- OpenZeppelinも`call()`の使用を推奨

#### インポートパスの変更

**Solidity 0.6.1（旧バージョン）**:
```solidity
import "@openzeppelin/contracts/GSN/Context.sol";
import "@openzeppelin/contracts/math/SafeMath.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
```

**Solidity 0.8.27（現在）**:
```solidity
import "@openzeppelin/contracts/utils/Context.sol";
// SafeMathは削除
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
```

**変更点**:
- OpenZeppelin v5.xでディレクトリ構造が変更
- GSN（Gas Station Network）関連は`utils`に統合
- SafeERC20は`token/ERC20/utils`に移動

### 2.2 virtual修飾子の重要性

**Solidity 0.6.0で導入**:
```solidity
// 基底コントラクト
function _preValidatePurchase(address beneficiary, uint256 weiAmount)
    internal
    view
    virtual  // オーバーライド可能
{
    require(beneficiary != address(0), "Crowdsale: beneficiary is the zero address");
    require(weiAmount != 0, "Crowdsale: weiAmount is 0");
}
```

**目的**:
- 継承したコントラクトで関数をオーバーライドできることを明示
- Solidity 0.6.0以降、オーバーライド可能な関数には`virtual`が必要
- オーバーライドする側は`override`キーワードを使用

**例**:
```solidity
// 継承先のコントラクト
function _preValidatePurchase(address beneficiary, uint256 weiAmount)
    internal
    view
    override  // 基底の関数をオーバーライド
{
    super._preValidatePurchase(beneficiary, weiAmount);
    // 追加のバリデーション
    require(isWhitelisted(beneficiary), "Not whitelisted");
}
```

## 3. Crowdsale.solの移行作業

### 3.1 移行前のコード（Solidity 0.6.1）

```solidity
pragma solidity ^0.6.0;

import "@openzeppelin/contracts/GSN/Context.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/math/SafeMath.sol";
import "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

contract Crowdsale is Context, ReentrancyGuard {
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    IERC20 private _token;
    address payable private _wallet;
    uint256 private _rate;
    uint256 private _weiRaised;

    constructor (uint256 rate, address payable wallet, IERC20 token) public {
        require(rate > 0, "Crowdsale: rate is 0");
        require(wallet != address(0), "Crowdsale: wallet is the zero address");
        require(address(token) != address(0), "Crowdsale: token is the zero address");

        _rate = rate;
        _wallet = wallet;
        _token = token;
    }

    function() external payable {
        buyTokens(_msgSender());
    }

    function buyTokens(address beneficiary) public nonReentrant payable {
        uint256 weiAmount = msg.value;
        _preValidatePurchase(beneficiary, weiAmount);

        uint256 tokens = _getTokenAmount(weiAmount);
        _weiRaised = _weiRaised.add(weiAmount);  // SafeMath使用

        _processPurchase(beneficiary, tokens);
        emit TokensPurchased(_msgSender(), beneficiary, weiAmount, tokens);

        _updatePurchasingState(beneficiary, weiAmount);
        _forwardFunds();
        _postValidatePurchase(beneficiary, weiAmount);
    }

    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {
        return weiAmount.mul(_rate);  // SafeMath使用
    }

    function _forwardFunds() internal {
        _wallet.transfer(msg.value);
    }
}
```

### 3.2 移行後のコード（Solidity 0.8.27）

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.27;

import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

contract Crowdsale is Context, ReentrancyGuard {
    using SafeERC20 for IERC20;

    IERC20 private _token;
    address payable private _wallet;
    uint256 private _rate;
    uint256 private _weiRaised;

    event TokensPurchased(
        address indexed purchaser,
        address indexed beneficiary,
        uint256 value,
        uint256 amount
    );

    constructor (uint256 rate_, address payable wallet_, IERC20 token_) {
        require(rate_ > 0, "Crowdsale: rate is 0");
        require(wallet_ != address(0), "Crowdsale: wallet is the zero address");
        require(address(token_) != address(0), "Crowdsale: token is the zero address");

        _rate = rate_;
        _wallet = wallet_;
        _token = token_;
    }

    receive() external payable {
        buyTokens(_msgSender());
    }

    function token() public view returns (IERC20) {
        return _token;
    }

    function wallet() public view returns (address payable) {
        return _wallet;
    }

    function rate() public view returns (uint256) {
        return _rate;
    }

    function weiRaised() public view returns (uint256) {
        return _weiRaised;
    }

    function buyTokens(address beneficiary) public nonReentrant payable {
        uint256 weiAmount = msg.value;
        _preValidatePurchase(beneficiary, weiAmount);

        uint256 tokens = _getTokenAmount(weiAmount);
        _weiRaised = _weiRaised + weiAmount;  // SafeMath不要

        _processPurchase(beneficiary, tokens);
        emit TokensPurchased(_msgSender(), beneficiary, weiAmount, tokens);

        _updatePurchasingState(beneficiary, weiAmount);
        _forwardFunds();
        _postValidatePurchase(beneficiary, weiAmount);
    }

    function _preValidatePurchase(address beneficiary, uint256 weiAmount)
        internal
        view
        virtual
    {
        require(beneficiary != address(0), "Crowdsale: beneficiary is the zero address");
        require(weiAmount != 0, "Crowdsale: weiAmount is 0");
    }

    function _postValidatePurchase(address beneficiary, uint256 weiAmount)
        internal
        view
        virtual
    {
        // 継承先でオーバーライド可能
    }

    function _deliverTokens(address beneficiary, uint256 tokenAmount)
        internal
        virtual
    {
        _token.safeTransfer(beneficiary, tokenAmount);
    }

    function _processPurchase(address beneficiary, uint256 tokenAmount)
        internal
        virtual
    {
        _deliverTokens(beneficiary, tokenAmount);
    }

    function _updatePurchasingState(address beneficiary, uint256 weiAmount)
        internal
        virtual
    {
        // 継承先でオーバーライド可能
    }

    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {
        return weiAmount * _rate;  // SafeMath不要
    }

    function _forwardFunds() internal virtual {
        (bool success, ) = _wallet.call{value: msg.value}("");
        require(success, "Crowdsale: failed to forward funds");
    }
}
```

### 3.3 移行作業の手順

1. **Solidityバージョンの更新**
   ```solidity
   pragma solidity ^0.6.0; → pragma solidity ^0.8.27;
   ```

2. **SPDX-License-Identifierの追加**
   ```solidity
   // SPDX-License-Identifier: MIT
   ```

3. **インポートパスの修正**
   - `GSN/Context.sol` → `utils/Context.sol`
   - `token/ERC20/SafeERC20.sol` → `token/ERC20/utils/SafeERC20.sol`
   - `math/SafeMath.sol` を削除

4. **SafeMathの削除**
   ```solidity
   using SafeMath for uint256; // 削除
   _weiRaised.add(weiAmount) → _weiRaised + weiAmount
   weiAmount.mul(_rate) → weiAmount * _rate
   ```

5. **コンストラクタの修正**
   ```solidity
   constructor (...) public { } → constructor (...) { }
   ```

   **引数名のシャドーイング回避**:
   ```solidity
   constructor (uint256 rate, ...) → constructor (uint256 rate_, ...)
   ```

6. **fallback関数をreceiveに変更**
   ```solidity
   function() external payable { } → receive() external payable { }
   ```

7. **virtual修飾子の追加**
   ```solidity
   function _preValidatePurchase(...) internal view virtual { }
   ```

8. **transfer()からcall()への変更**
   ```solidity
   _wallet.transfer(msg.value);
   →
   (bool success, ) = _wallet.call{value: msg.value}("");
   require(success, "Crowdsale: failed to forward funds");
   ```

9. **不要なコードの削除**
   ```solidity
   this; // silence state mutability warning
   ```

## 4. スマートコントラクトアーキテクチャの原則

### 4.1 単一責任原則（Single Responsibility Principle）

**悪い例：すべてを1つのコントラクトに詰め込む**
```solidity
contract BadToken is ERC20 {
    // トークン機能
    // + セール機能
    // + KYC機能
    // + ステーキング機能
    // → 複雑、テストしにくい、拡張しにくい
}
```

**良い例：責任を分離**
```solidity
// トークンはトークンの機能のみ
contract MyToken is ERC20 {
    constructor(uint256 initialSupply) ERC20("MyToken", "MTK") {
        _mint(msg.sender, initialSupply);
    }
}

// セールはセールの機能のみ
contract MyTokenSale is Crowdsale {
    constructor(
        uint256 rate,
        address payable wallet,
        IERC20 token
    ) Crowdsale(rate, wallet, token) {}
}

// KYCはKYCの機能のみ
contract KycContract {
    mapping(address => bool) public whitelist;
    // ...
}
```

### 4.2 関心の分離（Separation of Concerns）

**メリット**:
1. **保守性**: 各コントラクトが独立しており、修正が容易
2. **テスト性**: 個別にテスト可能
3. **再利用性**: 他のプロジェクトでも使用可能
4. **アップグレード性**: 1つのコントラクトのみを更新可能
5. **ガス効率**: 必要な機能のみデプロイ

**実例**:
```solidity
// トークンはERC-20標準のみを実装
MyToken (ERC20)
    ↓ アドレスを渡す
MyTokenSale (Crowdsale)
    ↓ ホワイトリストチェック
KycContract
```

### 4.3 拡張可能な設計

Crowdsaleコントラクトは**virtual関数**を提供し、継承による拡張をサポート：

```solidity
contract CappedCrowdsale is Crowdsale {
    uint256 private _cap;

    constructor(uint256 cap_) {
        require(cap_ > 0, "CappedCrowdsale: cap is 0");
        _cap = cap_;
    }

    function cap() public view returns (uint256) {
        return _cap;
    }

    function _preValidatePurchase(address beneficiary, uint256 weiAmount)
        internal
        view
        override
    {
        super._preValidatePurchase(beneficiary, weiAmount);
        require(weiRaised() + weiAmount <= _cap, "CappedCrowdsale: cap exceeded");
    }
}
```

**拡張の例**:
- **CappedCrowdsale**: 上限金額設定
- **TimedCrowdsale**: 開始・終了時刻設定
- **WhitelistedCrowdsale**: ホワイトリスト機能
- **RefundableCrowdsale**: 目標未達成時の返金機能

## 5. Crowdsaleコントラクトの動作原理

### 5.1 基本的なフロー

```
1. ユーザーがETHを送信
   ↓
2. receive()関数が呼ばれる
   ↓
3. buyTokens()が実行される
   ↓
4. _preValidatePurchase(): バリデーション
   ↓
5. _getTokenAmount(): トークン量を計算
   ↓
6. _processPurchase(): トークンを転送
   ↓
7. TokensPurchasedイベントを発火
   ↓
8. _forwardFunds(): ETHをウォレットに転送
```

### 5.2 主要な関数

#### buyTokens()
```solidity
function buyTokens(address beneficiary) public nonReentrant payable {
    uint256 weiAmount = msg.value;
    _preValidatePurchase(beneficiary, weiAmount);

    // トークン量を計算
    uint256 tokens = _getTokenAmount(weiAmount);

    // 集めた金額を更新
    _weiRaised = _weiRaised + weiAmount;

    // トークンを購入者に転送
    _processPurchase(beneficiary, tokens);

    // イベント発火
    emit TokensPurchased(_msgSender(), beneficiary, weiAmount, tokens);

    _updatePurchasingState(beneficiary, weiAmount);

    // ETHをウォレットに転送
    _forwardFunds();

    _postValidatePurchase(beneficiary, weiAmount);
}
```

**特徴**:
- `nonReentrant`: リエントランシー攻撃を防ぐ
- `payable`: ETHを受け取る
- フック関数を使った拡張可能な設計

#### _getTokenAmount()
```solidity
function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {
    return weiAmount * _rate;
}
```

**レートの例**:
- `rate = 1`: 1 wei = 1 トークン単位
- `rate = 100`: 1 wei = 100 トークン単位
- ETHで計算: 1 ETH (10^18 wei) × rate = トークン量

#### _forwardFunds()
```solidity
function _forwardFunds() internal virtual {
    (bool success, ) = _wallet.call{value: msg.value}("");
    require(success, "Crowdsale: failed to forward funds");
}
```

**セキュリティポイント**:
- `call()`を使用（`transfer()`より安全）
- 成功確認を必須とする
- virtual修飾子で拡張可能（エスクロー機能等）

### 5.3 拡張ポイント

Crowdsaleコントラクトは以下の関数を`virtual`として提供し、継承による拡張を可能にしています：

1. **_preValidatePurchase()**: 購入前のバリデーション
2. **_postValidatePurchase()**: 購入後のバリデーション
3. **_deliverTokens()**: トークン転送方法のカスタマイズ
4. **_processPurchase()**: 購入処理のカスタマイズ
5. **_updatePurchasingState()**: 状態更新のカスタマイズ
6. **_forwardFunds()**: 資金転送方法のカスタマイズ

## 6. コンパイルと検証

### 6.1 コンパイル実行

```bash
forge build
```

**結果**:
```
Compiling 36 files with Solc 0.8.27
Solc 0.8.27 finished in 690.35ms
Compiler run successful!
```

### 6.2 警告の解消

**シャドーイング警告**:
```
Warning (2519): This declaration shadows an existing declaration.
  --> src/Crowdsale.sol:57:18:
   |
57 |     constructor (uint256 rate, ...) {
   |                  ^^^^^^^^^^^^
```

**原因**:
- コンストラクタの引数名`rate`が関数名`rate()`と重複

**解決方法**:
```solidity
// 修正前
constructor (uint256 rate, address payable wallet, IERC20 token)

// 修正後
constructor (uint256 rate_, address payable wallet_, IERC20 token_)
```

## 7. 学習のポイント

### 7.1 習得した技術

1. **Solidityバージョン移行**
   - SafeMathの削除と組み込みオーバーフロー保護の活用
   - コンストラクタ可視性の変更
   - fallback/receive関数の分離
   - transfer()からcall()への移行

2. **OpenZeppelinの歴史と変遷**
   - Crowdsaleコントラクトの削除背景
   - バージョン間のディレクトリ構造変更
   - 戦略的な方向転換の理解

3. **スマートコントラクトアーキテクチャ**
   - 単一責任原則の実践
   - 関心の分離
   - virtual/override修飾子による拡張性
   - フック関数パターン

4. **セキュリティベストプラクティス**
   - ReentrancyGuardの使用
   - call()による安全な資金転送
   - 入力バリデーションの重要性

### 7.2 重要な理解事項

1. **レガシーコードの現代化**
   - 古いコントラクトを新しいSolidityバージョンに適応させる方法
   - 後方互換性とセキュリティのバランス

2. **エコシステムの変化への対応**
   - OpenZeppelinのような主要ライブラリの変更追跡
   - コミュニティフォーラムやドキュメントの活用
   - 削除された機能の代替手段の検討

3. **設計パターンの重要性**
   - 拡張可能な基底コントラクト
   - コントラクト間の相互作用
   - イベント駆動アーキテクチャ

### 7.3 実践的なスキル

1. **バージョン移行の手順**
   - インポートパスの更新
   - 非推奨機能の置き換え
   - 新機能の活用

2. **コンパイラ警告の解決**
   - シャドーイング問題の理解と解決
   - コード品質の向上

3. **ドキュメント読解**
   - OpenZeppelin公式ドキュメント
   - Solidityリリースノート
   - コミュニティフォーラム

## 8. OpenZeppelin Crowdsaleの削除に関する事実確認

### 8.1 公式情報

**削除時期**: 2020年、OpenZeppelin Contracts v3.0.0リリース時

**公式フォーラムでの議論**:
- [Where are Crowdsale contracts in OpenZeppelin Contracts 3.0?](https://forum.openzeppelin.com/t/where-are-crowdsale-contracts-in-openzeppelin-contracts-3-0/2348)
- [Why Crowdsale contracts have been deprecated for 3.0?](https://forum.openzeppelin.com/t/why-crowdsale-contracts-have-been-deprecated-for-3-0/27033)

**削除の理由**（公式発表より）:
1. 使用頻度の大幅な低下
2. Solidity 0.6への移行の複雑さ
3. 純粋なERC標準実装への注力

**利用可能性**:
- OpenZeppelin Contracts v2.5で引き続き利用可能
- [公式ドキュメント（v3.x Crowdsales）](https://docs.openzeppelin.com/contracts/3.x/crowdsales)
- セキュリティ問題に対するサポート継続

### 8.2 ICOブームの歴史

**2017年**: ICO（Initial Coin Offering）の全盛期
- Ethereum上でのトークンセールが盛況
- 多くのプロジェクトがCrowdsaleコントラクトを使用
- 規制の未整備により爆発的な成長

**2018-2019年**: 規制の強化と市場の冷え込み
- SEC（米国証券取引委員会）による規制強化
- 多くのICOプロジェクトの失敗
- 投資家の信頼低下

**2020年以降**: DeFiの台頭
- クラウドセールからDeFiプロトコルへのシフト
- IDO（Initial DEX Offering）の登場
- より分散化されたトークン配布メカニズム

### 8.3 現在の代替手段

**トークン配布の現代的な方法**:
1. **IDO（Initial DEX Offering）**: Uniswap等のDEXでの流動性提供
2. **エアドロップ**: コミュニティへの無償配布
3. **ステーキング報酬**: ネットワーク参加へのインセンティブ
4. **DAO投票**: ガバナンストークンの配布

**学習・教育目的での使用**:
- Crowdsaleコントラクトは依然として優れた学習教材
- スマートコントラクト間の相互作用を学ぶ
- セキュリティとアーキテクチャのベストプラクティス

## 9. 次のステップ

### 9.1 Crowdsaleの拡張

次の講義では、このCrowdsaleコントラクトを基盤として、独自のトークンセールを実装します：

1. **MyTokenSaleコントラクトの作成**
   - Crowdsaleを継承
   - カスタムバリデーションの追加
   - KYC機能の統合

2. **テストの作成**
   - Foundryによるテスト
   - エッジケースのカバー
   - セキュリティテスト

3. **デプロイとテスト**
   - Anvilへのデプロイ
   - トークン購入のシミュレーション
   - イベント監視

### 9.2 さらなる学習

1. **高度な機能の実装**
   - タイムロック機能
   - ベスティングスケジュール
   - マルチシグネチャウォレット

2. **セキュリティの深堀り**
   - 監査のベストプラクティス
   - よくある脆弱性の理解
   - テストカバレッジの向上

3. **ガス最適化**
   - ストレージの効率的な使用
   - 関数の最適化
   - バッチ処理の実装

## 10. まとめ

2025年12月26日は、OpenZeppelin Crowdsaleコントラクトの歴史的背景を理解し、Solidity 0.6.1から0.8.27への移行作業を完了しました。

### 10.1 重要な成果

- **歴史的コンテキストの理解**: ICOブームから現在までのエコシステムの変遷
- **バージョン移行の習得**: SafeMath削除、receive関数、call()への移行等
- **アーキテクチャ原則の実践**: 単一責任原則、関心の分離の重要性
- **拡張可能な設計の理解**: virtual/override修飾子の活用

### 10.2 今後の学習方向

- **Crowdsaleの実践的な使用**: MyTokenSaleコントラクトの実装
- **KYC機能の統合**: ホワイトリストとコンプライアンス
- **テストとセキュリティ**: 包括的なテストスイートの作成
- **現代的なトークン配布**: IDO、エアドロップ、ステーキング等の学習

レガシーコントラクトを現代のSolidityバージョンに適応させる作業を通じて、Solidityの進化、エコシステムの変遷、そしてスマートコントラクト設計の原則を深く理解することができました。この知識は、今後のDApp開発において重要な基盤となります。

## Sources

- [Crowdsales - OpenZeppelin Docs](https://docs.openzeppelin.com/contracts/3.x/crowdsales)
- [Where are Crowdsale contracts in OpenZeppelin Contracts 3.0? - OpenZeppelin Forum](https://forum.openzeppelin.com/t/where-are-crowdsale-contracts-in-openzeppelin-contracts-3-0/2348)
- [Why Crowdsale contracts have been deprecated for 3.0? - OpenZeppelin Forum](https://forum.openzeppelin.com/t/why-crowdsale-contracts-have-been-deprecated-for-3-0/27033)
- [How To Modify Crowdsale & MintedCrowdsale Solidity Contracts To Work With OpenZeppelin 4.0](https://www.bluelabellabs.com/blog/crowdsale-mintedcrowdsale-solidity-contracts-openzeppelin/)
