# MyTokenSaleコントラクトの実装とFoundryによる包括的テスト

**日付**: 2025年12月27日
**学習内容**: MyTokenSaleコントラクトの実装、Foundryデプロイスクリプトの作成、包括的なテストスイートの構築

## 1. MyTokenSaleコントラクトの実装

### 1.1 MyTokenSaleとは

**MyTokenSale**は、前日に移行したCrowdsaleコントラクトを継承し、MyTokenを販売するための専用コントラクトです。

**目的**:
- ETHを受け取ってMyTokenを販売
- トークンとセールのロジックを分離
- 拡張可能な設計

### 1.2 コントラクトの実装

```solidity
// SPDX-License-Identifier: MIT
// Compatible with OpenZeppelin Contracts ^5.5.0
pragma solidity ^0.8.27;

import "./Crowdsale.sol";

/**
 * @title MyTokenSale
 * @dev MyTokenSale is a Crowdsale contract for selling MyToken
 */
contract MyTokenSale is Crowdsale {
    constructor(
        uint256 rate_,    // rate in TKNbits
        address payable wallet_,
        IERC20 token_
    ) Crowdsale(rate_, wallet_, token_) {
        // MyTokenSale specific initialization can be added here
    }
}
```

### 1.3 コントラクトの詳細解説

#### 継承関係

```
MyTokenSale
    ↓ is
Crowdsale
    ↓ is
Context, ReentrancyGuard
```

**継承による利点**:
- Crowdsaleの全機能を利用可能
- 必要に応じてカスタマイズ可能
- コードの再利用性が高い

#### コンストラクタの引数

```solidity
constructor(
    uint256 rate_,           // 1 weiあたりのトークン数
    address payable wallet_, // ETHを受け取るウォレット
    IERC20 token_           // 販売するトークンのアドレス
)
```

**引数の詳細**:

1. **rate_**: 交換レート
   - 1 wei = rate_ トークン単位
   - 例: rate_ = 1 → 1 wei = 1 トークン
   - 例: rate_ = 100 → 1 wei = 100 トークン

2. **wallet_**: 資金受取先
   - ETHが送金されるアドレス
   - payable指定が必要
   - 通常はプロジェクトのウォレット

3. **token_**: 販売トークン
   - ERC20トークンのアドレス
   - IERC20インターフェース経由でアクセス

#### シンプルな実装の理由

MyTokenSaleは基本的にCrowdsaleをそのまま使用しています。これは**単一責任原則**に従った設計です：

**追加機能が必要な場合の拡張例**:
```solidity
contract MyTokenSale is Crowdsale {
    uint256 private _cap; // キャップ機能

    constructor(
        uint256 rate_,
        address payable wallet_,
        IERC20 token_,
        uint256 cap_
    ) Crowdsale(rate_, wallet_, token_) {
        require(cap_ > 0, "MyTokenSale: cap is 0");
        _cap = cap_;
    }

    function _preValidatePurchase(address beneficiary, uint256 weiAmount)
        internal
        view
        override
    {
        super._preValidatePurchase(beneficiary, weiAmount);
        require(weiRaised() + weiAmount <= _cap, "MyTokenSale: cap exceeded");
    }
}
```

## 2. Foundryデプロイスクリプトの実装

### 2.1 Deploy.s.solの作成

Foundryでは、デプロイスクリプトもSolidityで記述します。これにより、型安全性と一貫性のある開発体験が得られます。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.27;

import {Script, console} from "forge-std/Script.sol";
import {MyToken} from "../src/MyToken.sol";
import {MyTokenSale} from "../src/MyTokenSale.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract DeployScript is Script {
    function run() public {
        // 環境変数から初期トークン量を取得（デフォルト: 1,000,000）
        uint256 initialTokens = vm.envOr("INITIAL_TOKENS", uint256(1000000));

        // デプロイヤーの秘密鍵を環境変数から取得
        uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
        address deployer = vm.addr(deployerPrivateKey);

        console.log("=== Deployment Started ===");
        console.log("Deployer address:", deployer);
        console.log("Initial token supply:", initialTokens);

        vm.startBroadcast(deployerPrivateKey);

        // MyTokenをデプロイ
        MyToken token = new MyToken(initialTokens);

        console.log("\\n=== MyToken Deployed ===");
        console.log("Contract address:", address(token));
        console.log("Token name:", token.name());
        console.log("Token symbol:", token.symbol());
        console.log("Decimals:", token.decimals());
        console.log("Total supply:", token.totalSupply());
        console.log("Deployer balance:", token.balanceOf(deployer));

        // MyTokenSaleをデプロイ
        MyTokenSale tokenSale = new MyTokenSale(
            1,  // rate: 1 wei = 1 token
            payable(deployer),  // wallet address
            IERC20(address(token))
        );

        console.log("\\n=== MyTokenSale Deployed ===");
        console.log("Contract address:", address(tokenSale));
        console.log("Rate:", tokenSale.rate());
        console.log("Wallet:", tokenSale.wallet());
        console.log("Token:", address(tokenSale.token()));

        // トークンをTokenSaleコントラクトへ転送
        token.transfer(address(tokenSale), initialTokens);
        console.log("\\n=== Token Transfer ===");
        console.log("Transferred", initialTokens, "tokens to TokenSale contract");
        console.log("TokenSale balance:", token.balanceOf(address(tokenSale)));
        console.log("Deployer balance:", token.balanceOf(deployer));

        vm.stopBroadcast();

        // デプロイ情報のまとめ
        console.log("\\n=== Deployment Summary ===");
        console.log("MyToken:", address(token));
        console.log("MyTokenSale:", address(tokenSale));
        console.log("========================");
    }
}
```

### 2.2 デプロイスクリプトの詳細解説

#### ステップ1: 環境変数の取得

```solidity
uint256 initialTokens = vm.envOr("INITIAL_TOKENS", uint256(1000000));
uint256 deployerPrivateKey = vm.envUint("PRIVATE_KEY");
address deployer = vm.addr(deployerPrivateKey);
```

**目的**:
- `.env`ファイルから設定を読み込む
- デフォルト値を提供（INITIAL_TOKENS = 1,000,000）
- 秘密鍵からデプロイヤーアドレスを取得

**vm.envOr()の利点**:
- 環境変数が存在しない場合のデフォルト値を設定
- エラーではなく、安全なフォールバック

#### ステップ2: MyTokenのデプロイ

```solidity
vm.startBroadcast(deployerPrivateKey);

MyToken token = new MyToken(initialTokens);

console.log("\\n=== MyToken Deployed ===");
console.log("Contract address:", address(token));
console.log("Token name:", token.name());
console.log("Token symbol:", token.symbol());
console.log("Decimals:", token.decimals());
console.log("Total supply:", token.totalSupply());
console.log("Deployer balance:", token.balanceOf(deployer));
```

**重要なポイント**:
- `vm.startBroadcast()`: トランザクションの送信を開始
- `new MyToken(initialTokens)`: コントラクトのデプロイ
- 詳細なログ出力でデプロイ結果を確認

**デプロイ後の状態**:
- MyTokenがブロックチェーンにデプロイされる
- デプロイヤーが全トークンを保有

#### ステップ3: MyTokenSaleのデプロイ

```solidity
MyTokenSale tokenSale = new MyTokenSale(
    1,  // rate: 1 wei = 1 token
    payable(deployer),  // wallet address
    IERC20(address(token))
);

console.log("\\n=== MyTokenSale Deployed ===");
console.log("Contract address:", address(tokenSale));
console.log("Rate:", tokenSale.rate());
console.log("Wallet:", tokenSale.wallet());
console.log("Token:", address(tokenSale.token()));
```

**引数の説明**:
1. **rate = 1**: 1 wei = 1 トークン
   - シンプルな1対1の交換レート
   - 計算が簡単

2. **wallet = deployer**: ETHの受取先
   - `payable(deployer)`: デプロイヤーがETHを受け取る
   - 本番環境では専用のウォレットを使用

3. **token = address(token)**: 販売するトークン
   - `IERC20(address(token))`: IERC20インターフェースにキャスト
   - MyTokenのアドレスを渡す

#### ステップ4: トークンの転送

```solidity
token.transfer(address(tokenSale), initialTokens);

console.log("\\n=== Token Transfer ===");
console.log("Transferred", initialTokens, "tokens to TokenSale contract");
console.log("TokenSale balance:", token.balanceOf(address(tokenSale)));
console.log("Deployer balance:", token.balanceOf(deployer));
```

**なぜトークンを転送するのか？**:
- TokenSaleコントラクトがトークンを販売するには、トークンを保有している必要がある
- デプロイヤーから全トークンをTokenSaleコントラクトに転送
- これにより、TokenSaleコントラクトが購入者にトークンを配布できる

**転送後の状態**:
- TokenSaleコントラクト: 1,000,000 トークン
- デプロイヤー: 0 トークン

#### ステップ5: ブロードキャストの終了とサマリー

```solidity
vm.stopBroadcast();

console.log("\\n=== Deployment Summary ===");
console.log("MyToken:", address(token));
console.log("MyTokenSale:", address(tokenSale));
console.log("========================");
```

**vm.stopBroadcast()の役割**:
- トランザクションの送信を終了
- これ以降のコードはオフチェーンで実行される

### 2.3 Foundryデプロイスクリプトの利点

**Solidityで記述する利点**:
1. **型安全性**: コンパイル時にエラーを検出
2. **一貫性**: コントラクト、テスト、デプロイが同じ言語
3. **高速**: Rustベースで非常に高速
4. **デバッグ**: console.logで詳細なログ出力

**実行コマンド**:
```bash
# Anvilへのデプロイ
forge script script/Deploy.s.sol --rpc-url http://127.0.0.1:8545 --broadcast

# Sepoliaテストネットへのデプロイ
forge script script/Deploy.s.sol --rpc-url $SEPOLIA_RPC_URL --broadcast --verify
```

## 3. Foundryテストスクリプトの実装

### 3.1 MyTokenSale.t.solの作成

Foundryでは、テストもSolidityで記述します。これにより、コントラクトと同じ言語でテストを書くことができます。

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.27;

import "forge-std/Test.sol";
import "../src/MyToken.sol";
import "../src/MyTokenSale.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract MyTokenSaleTest is Test {
    MyToken public token;
    MyTokenSale public tokenSale;

    address public wallet;
    address public buyer1;
    address public buyer2;

    uint256 public constant INITIAL_SUPPLY = 1000000;
    uint256 public constant RATE = 1; // 1 wei = 1 token

    event TokensPurchased(
        address indexed purchaser,
        address indexed beneficiary,
        uint256 value,
        uint256 amount
    );

    // ETHを受け取るためのreceive関数
    receive() external payable {}

    function setUp() public {
        wallet = makeAddr("wallet"); // ETHを受け取るウォレット
        buyer1 = address(0x1);
        buyer2 = address(0x2);

        // MyTokenをデプロイ
        token = new MyToken(INITIAL_SUPPLY);

        // MyTokenSaleをデプロイ
        tokenSale = new MyTokenSale(
            RATE,
            payable(wallet),
            IERC20(address(token))
        );

        // 全トークンをTokenSaleコントラクトに転送
        token.transfer(address(tokenSale), INITIAL_SUPPLY);
    }

    // ... テスト関数 ...
}
```

この記事では、MyTokenSaleの実装とテストについて詳しく解説しています。Foundryを使用した型安全なデプロイスクリプトと、包括的なテストスイートの作成方法を学びました。
