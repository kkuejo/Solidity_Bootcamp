# Wagmi + React + Viemで構築するSupply Chain DApp

**日付**: 2025年11月20日
**学習内容**: Wagmi v2とReactを使用したSupply Chain DAppの構築、スマートコントラクトとのインタラクション、リアルタイムイベント監視、MetaMask連携、トラブルシューティング

## 1. プロジェクト概要

### 1.1 このDAppの目的

このSupply Chain DAppは、商品の作成から支払い、配達までのサプライチェーンを管理するアプリケーションです。ブロックチェーン上で各商品の状態を追跡し、透明性の高い取引を実現します。

### 1.2 主な機能

1. **商品作成**: 管理者が新しい商品を作成
2. **支払い処理**: 商品コントラクトに直接ETHを送信して支払い
3. **配達処理**: 管理者が配達完了を記録
4. **リアルタイム通知**: 支払い完了時に緑色の通知を表示
5. **商品一覧表示**: すべての商品の状態、価格、コントラクトアドレスを表示

### 1.3 プロジェクト構造

```
supply-chain-project/
├── contracts/              # Foundryプロジェクト
│   ├── src/
│   │   ├── Ownable.sol    # 所有者管理
│   │   ├── Item.sol       # 個別商品コントラクト
│   │   └── ItemManager.sol # メイン管理コントラクト
│   ├── script/
│   │   └── Deploy.s.sol   # デプロイスクリプト
│   └── test/
│       └── ItemManager.t.sol # テスト
├── frontend/               # Reactフロントエンド
│   ├── src/
│   │   ├── components/
│   │   │   └── SupplyChain.tsx # メインコンポーネント
│   │   ├── contracts/
│   │   │   ├── ItemManager.json # ItemManager ABI
│   │   │   └── Item.json        # Item ABI
│   │   ├── wagmi.config.ts      # Wagmi設定
│   │   ├── App.tsx              # ルートコンポーネント
│   │   └── main.tsx             # エントリーポイント
│   ├── index.html
│   ├── .env                     # 環境変数
│   └── vite.config.ts           # Vite設定
└── history.md                   # 構築手順メモ
```

## 2. スマートコントラクトの設計と実装

### 2.1 Foundryプロジェクトの初期化

```bash
# プロジェクトルートディレクトリで実行
forge init contracts
cd contracts
```

### 2.2 OpenZeppelinのインストール

```bash
forge install OpenZeppelin/openzeppelin-contracts
```

[contracts/foundry.toml](contracts/foundry.toml) に以下を追加：

```toml
[profile.default]
src = "src"
out = "out"
libs = ["lib"]
solc_version = "0.8.20"
remappings = [
    "@openzeppelin/=lib/openzeppelin-contracts/"
]
```

**remappingsとは**: Solidityファイル内で `@openzeppelin/` というプレフィックスを使って、実際のライブラリパス `lib/openzeppelin-contracts/` にマッピングする設定です。これにより、長いパスを書く必要がなくなります。

### 2.3 Item.sol - 個別商品コントラクト

[contracts/src/Item.sol](contracts/src/Item.sol):

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract Item {
    uint256 public priceInWei;
    uint256 public paidWei;
    uint256 public index;
    address public parentContract;

    constructor(
        address _parentContract,
        uint256 _priceInWei,
        uint256 _index
    ) {
        priceInWei = _priceInWei;
        index = _index;
        parentContract = _parentContract;
    }

    receive() external payable {
        require(msg.value == priceInWei, "We don't support partial payments");
        require(paidWei == 0, "Item is already paid!");

        paidWei += msg.value;

        (bool success, ) = parentContract.call{value: msg.value}(
            abi.encodeWithSignature("triggerPayment(uint256)", index)
        );
        require(success, "Payment trigger failed");
    }

    fallback() external {}
}
```

**重要なポイント**:

1. **receive()関数**: ETHを直接受け取る特殊な関数
   - `msg.value`: 送信されたETHの量（Wei単位）
   - 正確な金額のみ受け付け（部分払い不可）
   - 二重払いをブロック

2. **コールバック機構**:
   - ItemManager の `triggerPayment()` を呼び出し
   - `abi.encodeWithSignature()` で関数呼び出しをエンコード
   - `call{value: msg.value}()` でETHを転送しながら関数実行

3. **fallback()関数**: データ付きの呼び出しを受け付ける（空実装）

### 2.4 ItemManager.sol - メイン管理コントラクト

[contracts/src/ItemManager.sol](contracts/src/ItemManager.sol) の主要部分:

```solidity
contract ItemManager is Ownable {
    enum SupplyChainSteps {
        Created,    // 0: 作成済み
        Paid,       // 1: 支払い済み
        Delivered   // 2: 配達済み
    }

    struct S_Item {
        Item item;
        SupplyChainSteps step;
        string identifier;
    }

    mapping(uint256 => S_Item) public items;
    uint256 public itemIndex;

    event SupplyChainStep(
        uint256 indexed itemIndex,
        uint256 step,
        address itemAddress
    );

    function createItem(string memory _identifier, uint256 _priceInWei)
        public
        onlyOwner
    {
        Item item = new Item(address(this), _priceInWei, itemIndex);
        items[itemIndex].item = item;
        items[itemIndex].step = SupplyChainSteps.Created;
        items[itemIndex].identifier = _identifier;

        emit SupplyChainStep(itemIndex, uint256(SupplyChainSteps.Created), address(item));
        itemIndex++;
    }

    function triggerPayment(uint256 _index) public payable {
        Item item = items[_index].item;
        require(
            address(item) == msg.sender,
            "Only items are allowed to update themselves"
        );
        require(
            item.priceInWei() == msg.value,
            "Not fully paid yet"
        );
        require(
            items[_index].step == SupplyChainSteps.Created,
            "Item is further in the supply chain"
        );

        items[_index].step = SupplyChainSteps.Paid;
        emit SupplyChainStep(_index, uint256(SupplyChainSteps.Paid), address(item));
    }

    function triggerDelivery(uint256 _index) public onlyOwner {
        require(
            items[_index].step == SupplyChainSteps.Paid,
            "Item is further in the supply chain"
        );

        items[_index].step = SupplyChainSteps.Delivered;
        emit SupplyChainStep(
            _index,
            uint256(SupplyChainSteps.Delivered),
            address(items[_index].item)
        );
    }
}
```

**設計のポイント**:

1. **列挙型（enum）**: 商品の状態を3つに定義
   - Created（0）: 作成直後
   - Paid（1）: 支払い完了
   - Delivered（2）: 配達完了

2. **構造体（struct）**: 商品情報をまとめて管理
   - `item`: Itemコントラクトのインスタンス
   - `step`: 現在の状態
   - `identifier`: 商品名

3. **イベント**: フロントエンドでリアルタイム監視可能
   - `indexed`: インデックス化されたパラメータ（検索可能）

4. **権限管理**:
   - `createItem`: 管理者のみ（`onlyOwner`）
   - `triggerPayment`: Itemコントラクトのみ
   - `triggerDelivery`: 管理者のみ

### 2.5 テストの実行

```bash
cd contracts
forge test -vv
```

**`-vv` フラグ**: 詳細な出力を表示（失敗したテストの詳細を確認可能）

### 2.6 Anvilへのデプロイ

#### ステップ1: Anvilの起動

別ターミナルで実行：

```bash
anvil
```

**確認事項**:
- `Listening on 127.0.0.1:8545` と表示される
- デフォルトアカウント（10個）が表示される
- 最初のアカウント: `0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266`
- 秘密鍵: `0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80`

#### ステップ2: デプロイスクリプトの実行

```bash
cd contracts
forge script script/Deploy.s.sol --rpc-url http://localhost:8545 --broadcast
```

**出力例**:
```
[⠊] Compiling...
[⠒] Compiling 4 files with 0.8.20
[⠢] Solc 0.8.20 finished in 1.23s
Compiler run successful!
Script ran successfully.

== Logs ==
  Deployed ItemManager at: 0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0
```

**重要**: デプロイされたアドレス（例: `0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0`）をメモしておきます。

## 3. Reactフロントエンドの構築

### 3.1 プロジェクトの初期化

```bash
# プロジェクトルートに戻る
cd ..

# Vite + React + TypeScriptプロジェクトを作成
npm create vite@latest frontend -- --template react-ts

# フロントエンドディレクトリに移動
cd frontend

# 依存関係をインストール
npm install
```

### 3.2 必要なパッケージのインストール

```bash
# Wagmi, Viem, TanStack Queryをインストール
npm install viem wagmi @wagmi/core @wagmi/connectors
npm install @tanstack/react-query
```

**各パッケージの役割**:

- **viem**: Ethereumとやり取りするためのTypeScriptライブラリ
- **wagmi**: ReactでEthereumを扱うためのフック集
- **@tanstack/react-query**: 非同期データの管理（Wagmiが内部で使用）

### 3.3 ABIファイルのコピー

```bash
# contractsディレクトリが存在する場合のみ作成
mkdir -p src/contracts

# ItemManagerのABIをコピー
cp ../contracts/out/ItemManager.sol/ItemManager.json src/contracts/

# ItemのABIをコピー
cp ../contracts/out/Item.sol/Item.json src/contracts/
```

**ABIとは**: Application Binary Interface（アプリケーションバイナリインターフェース）の略。スマートコントラクトの関数やイベントの定義を記述したJSONファイルで、フロントエンドからコントラクトを呼び出すために必要です。

### 3.4 環境変数の設定

[frontend/.env](frontend/.env) を作成：

```bash
VITE_ITEM_MANAGER_ADDRESS=0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0
```

**注意**: デプロイ時に表示されたItemManagerのアドレスを設定してください。

**Viteの環境変数ルール**:
- 環境変数は `VITE_` プレフィックスが必要
- フロントエンドで `import.meta.env.VITE_ITEM_MANAGER_ADDRESS` として参照可能

### 3.5 Wagmi設定ファイルの作成

[frontend/src/wagmi.config.ts](frontend/src/wagmi.config.ts):

```typescript
import { http, createConfig } from 'wagmi'
import { localhost } from 'wagmi/chains'
import { injected } from 'wagmi/connectors'

export const config = createConfig({
  chains: [localhost],
  connectors: [injected()],
  transports: {
    [localhost.id]: http('http://127.0.0.1:8545'),
  },
})
```

**設定の説明**:

- **chains**: 接続するブロックチェーン（localhostはAnvil用）
- **connectors**: ウォレット接続方法（`injected()` はMetaMask等のブラウザウォレット）
- **transports**: RPC通信方法（HTTP経由でAnvilに接続）

### 3.6 App.tsxの作成

[frontend/src/App.tsx](frontend/src/App.tsx):

```typescript
import { WagmiProvider } from 'wagmi'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { config } from './wagmi.config'
import SupplyChain from './components/SupplyChain'

const queryClient = new QueryClient()

function App() {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <div className="App">
          <SupplyChain />
        </div>
      </QueryClientProvider>
    </WagmiProvider>
  )
}

export default App
```

**プロバイダーの役割**:

1. **WagmiProvider**: Wagmi機能を子コンポーネントで使用可能にする
2. **QueryClientProvider**: 非同期データのキャッシュと管理

### 3.7 SupplyChain.tsxの作成

[frontend/src/components/SupplyChain.tsx](frontend/src/components/SupplyChain.tsx) の主要部分:

#### 3.7.1 インポートと基本設定

```typescript
import { useState, useEffect } from 'react'
import { useAccount, useConnect, useWatchContractEvent, useWriteContract, useWaitForTransactionReceipt, useReadContract } from 'wagmi'
import { formatEther } from 'viem'
import ItemManagerABI from '../contracts/ItemManager.json'
import ItemABI from '../contracts/Item.json'

const ITEM_MANAGER_ADDRESS = import.meta.env.VITE_ITEM_MANAGER_ADDRESS as `0x${string}`
```

**Wagmi v2の主要フック**:

- **useAccount**: 接続中のアカウント情報を取得
- **useConnect**: ウォレット接続を管理
- **useReadContract**: コントラクトの読み取り専用関数を呼び出し
- **useWriteContract**: トランザクションを送信
- **useWaitForTransactionReceipt**: トランザクションの完了を待機
- **useWatchContractEvent**: イベントをリアルタイム監視

#### 3.7.2 ItemCardコンポーネント - 個別商品表示

```typescript
function ItemCard({ index }: { index: number }) {
  const { data: itemData } = useReadContract({
    address: ITEM_MANAGER_ADDRESS,
    abi: ItemManagerABI.abi,
    functionName: 'items',
    args: [BigInt(index)],
  }) as { data: [string, number, string] | undefined }

  const itemAddress = itemData?.[0] as `0x${string}` | undefined
  const step = itemData?.[1]
  const identifier = itemData?.[2]

  const { data: priceInWei } = useReadContract({
    address: itemAddress,
    abi: ItemABI as any,
    functionName: 'priceInWei',
  }) as { data: bigint | undefined }

  const statusNames = ['Created', 'Paid', 'Delivered']

  if (!itemData) return <div>Loading item {index}...</div>

  return (
    <div style={{
      border: '1px solid #ccc',
      padding: '15px',
      margin: '10px 0',
      borderRadius: '8px',
      backgroundColor: step === 1 ? '#e8f5e9' : step === 2 ? '#e3f2fd' : '#fff',
      color: '#000'
    }}>
      <h3 style={{ color: '#000' }}>Item #{index}: {identifier}</h3>
      <p style={{ color: '#000' }}><strong>Contract Address:</strong> {itemAddress}</p>
      <p style={{ color: '#000' }}><strong>Price:</strong> {priceInWei ? `${priceInWei.toString()} Wei (${formatEther(priceInWei)} ETH)` : 'Loading...'}</p>
      <p style={{ color: '#000' }}><strong>Status:</strong> <span style={{
        fontWeight: 'bold',
        color: step === 1 ? '#2e7d32' : step === 2 ? '#1565c0' : '#666'
      }}>{step !== undefined ? statusNames[step] : 'Unknown'}</span></p>
    </div>
  )
}
```

**実装のポイント**:

1. **二段階のデータ取得**:
   - 1回目: ItemManagerから商品情報を取得
   - 2回目: Itemコントラクトから価格情報を取得

2. **型アサーション**:
   - `itemData?.[0]` を `0x${string}` 型にキャスト（Viemの厳密な型要求）

3. **カラーコーディング**:
   - 白背景: Created（作成済み）
   - 緑背景 (`#e8f5e9`): Paid（支払い済み）
   - 青背景 (`#e3f2fd`): Delivered（配達済み）

4. **formatEther**: Wei単位をETH単位に変換（1 ETH = 10^18 Wei）

#### 3.7.3 イベント監視

```typescript
useWatchContractEvent({
  address: ITEM_MANAGER_ADDRESS,
  abi: ItemManagerABI.abi,
  eventName: 'SupplyChainStep',
  onLogs(logs) {
    logs.forEach((log: any) => {
      if (log.args.step === 1n) { // Paid
        setPaymentAlert(`Item at ${log.args.itemAddress} was paid! Deliver it now!`)
      }
    })
  },
})
```

**重要なポイント**:

- **リアルタイム監視**: ブロックチェーン上のイベントを検知
- **BigInt比較**: `1n` はBigInt型の1（`log.args.step` もBigInt型）
- **プロパティ名**: `log.args.step`（`_step` ではない）
  - これは最初のバグの原因でした

#### 3.7.4 商品作成処理

```typescript
const handleCreateItem = async () => {
  try {
    writeContract({
      address: ITEM_MANAGER_ADDRESS,
      abi: ItemManagerABI.abi,
      functionName: 'createItem',
      args: [itemName, BigInt(cost)],
    })
  } catch (error) {
    console.error('Error creating item:', error)
    alert(`Error: ${error}`)
  }
}

useEffect(() => {
  if (isConfirmed) {
    alert('Item created successfully!')
    refetchItemIndex() // アイテム一覧を更新
  }
}, [isConfirmed, refetchItemIndex])
```

**処理フロー**:

1. `writeContract()` でトランザクションを送信
2. `hash` に トランザクションハッシュが格納される
3. `useWaitForTransactionReceipt` がトランザクション完了を待機
4. `isConfirmed` が `true` になったら `useEffect` が実行
5. `refetchItemIndex()` で最新のアイテム数を取得

### 3.8 CSP設定の追加

Content Security Policy（CSP）エラーを解決するための設定。

#### [frontend/vite.config.ts](frontend/vite.config.ts):

```typescript
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

export default defineConfig({
  plugins: [react()],
  define: {
    global: 'globalThis',
  },
  server: {
    headers: {
      'Content-Security-Policy': "script-src 'self' 'unsafe-eval' 'unsafe-inline';",
    },
  },
})
```

#### [frontend/index.html](frontend/index.html):

```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-eval' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; connect-src 'self' http://127.0.0.1:8545 http://localhost:8545;" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>frontend</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
```

**CSPとは**: Content Security Policyは、XSS（クロスサイトスクリプティング）攻撃を防ぐためのセキュリティ機能です。

- `'unsafe-eval'`: Viemが内部でeval()を使用するため必要
- `connect-src`: AnvilのRPCエンドポイントへの接続を許可

## 4. 動作確認とテスト

### 4.1 フロントエンドの起動

```bash
cd frontend
npm run dev
```

ブラウザで `http://localhost:5175` を開きます。

### 4.2 MetaMaskの設定

#### ステップ1: ネットワーク追加

MetaMaskで以下の設定でネットワークを追加：

- **ネットワーク名**: Anvil Localhost
- **新しいRPC URL**: `http://127.0.0.1:8545`
- **チェーンID**: `31337`
- **通貨記号**: ETH

#### ステップ2: アカウントのインポート

Anvilのデフォルトアカウント（オーナーアカウント）をインポート：

1. MetaMaskで「アカウントをインポート」を選択
2. 秘密鍵を入力: `0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80`
3. アカウント名を「Anvil Owner」等に変更（任意）

**なぜオーナーアカウントが必要か**: `createItem()` 関数は `onlyOwner` 修飾子がついているため、コントラクトをデプロイしたアカウントからしか実行できません。

### 4.3 商品作成のテスト

1. MetaMaskでフロントエンドに接続
2. **Cost (in Wei)** に価格を入力（例: `100`）
3. **Item Name** に商品名を入力（例: `Laptop`）
4. **Create new Item** ボタンをクリック
5. MetaMaskでトランザクションを承認
6. 「Item created successfully!」と表示されたら成功

**確認ポイント**:
- 商品がリストに表示される
- Status: Created（白背景）
- Contract Address が表示される
- Price が表示される（Wei と ETH）

### 4.4 支払いのテスト

支払いは Item コントラクトに直接ETHを送信します。

#### 方法1: コマンドラインから支払い

```bash
# Itemコントラクトのアドレスをメモしておく（例: 0x61ef99673A65BeE0512b8d1eB1aA656866D24296）
# 価格分のWeiを送信（例: 100 Wei）

cast send 0x61ef99673A65BeE0512b8d1eB1aA656866D24296 \
  --value 100 \
  --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
```

#### 方法2: MetaMaskから支払い

1. MetaMaskで送金画面を開く
2. **To**: Itemコントラクトのアドレスを入力
3. **Amount**: 価格分のETHを入力（Wei換算して）
4. トランザクションを送信

**支払い成功の確認**:
- フロントエンドに緑色の通知が表示される
  ```
  Item at 0x61ef99673A65BeE0512b8d1eB1aA656866D24296 was paid! Deliver it now!
  ```
- 商品の背景色が緑色に変わる
- Status: Paid

**支払いの仕組み**:

1. Itemコントラクトの `receive()` 関数が起動
2. 金額とステータスをチェック
3. ItemManager の `triggerPayment()` を呼び出し
4. `SupplyChainStep` イベントが発火
5. フロントエンドの `useWatchContractEvent` が検知
6. 緑色の通知を表示

### 4.5 配達完了のテスト

配達完了は管理者のみが実行可能です。

```bash
# Item #0を配達完了にする場合
cast send 0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0 \
  "triggerDelivery(uint256)" 0 \
  --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80
```

**コマンドの説明**:
- `0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0`: ItemManagerのアドレス
- `"triggerDelivery(uint256)"`: 関数シグネチャ
- `0`: アイテムインデックス（Item #0）
- `--private-key`: オーナーの秘密鍵

**配達完了の確認**:
- 商品の背景色が青色に変わる
- Status: Delivered

## 5. トラブルシューティング

### 5.1 エラー1: ファイル名の大文字小文字の違い

**エラーメッセージ**:
```
File name 'App.tsx' differs from already included file name 'APP.tsx' only in casing
```

**原因**:
- ファイルシステムの大文字小文字の扱いの違い
- 同じファイルが異なる名前で認識されている

**解決方法**:
```bash
# 古いファイルを削除
rm src/App.tsx

# 新しいファイルをリネーム
mv src/APP.tsx src/App.tsx
```

### 5.2 エラー2: 未使用インポートの警告

**エラーメッセージ**:
```
'parseEther' is declared but its value is never read.
'formatEther' is declared but its value is never read.
```

**原因**: インポートしたが使用していない

**解決方法**:
- 使用しない場合: import文から削除
- 使用する場合: コード内で使用（ItemCardで `formatEther` を使用）

### 5.3 エラー3: CSP (Content Security Policy) エラー

**エラーメッセージ**:
```
Refused to evaluate a string as JavaScript because 'unsafe-eval' is not an allowed source of script
```

**原因**: Viemが内部でeval()を使用しているが、CSPで許可されていない

**解決方法**: [3.8 CSP設定の追加](#38-csp設定の追加) を参照

### 5.4 エラー4: 間違ったコントラクトアドレス

**症状**: トランザクションが失敗する

**原因**: `.env` ファイルに秘密鍵を設定していた（コントラクトアドレスではない）

**解決方法**:
```bash
# .env を編集
VITE_ITEM_MANAGER_ADDRESS=0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0
```

**確認方法**: アドレスの長さは42文字（`0x` + 40文字）

### 5.5 エラー5: トランザクション承認エラー

**症状**: トランザクション作成時にエラーが発生

**原因**: 管理者アカウント以外で `createItem()` を実行しようとした

**解決方法**:
1. MetaMaskでオーナーアカウントに切り替え
2. オーナーアカウント（`0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266`）をインポート

### 5.6 エラー6: 支払い通知が表示されない

**症状**: 支払いが成功しても緑色の通知が表示されない

**原因**: イベント監視のプロパティ名が間違っていた（`log.args._step` と書いていた）

**解決方法**:
```typescript
// 修正前
if (log.args._step === 1n) {

// 修正後
if (log.args.step === 1n) {
```

**デバッグ方法**:
```typescript
// ログを追加して確認
console.log('Event received:', log.args)
```

### 5.7 エラー7: Item.json が見つからない

**エラーメッセージ**:
```
GET http://localhost:5175/src/contracts/Item.json net::ERR_ABORTED 500
```

**原因**: ItemのABIファイルがコピーされていない

**解決方法**:
```bash
cp ../contracts/out/Item.sol/Item.json src/contracts/
```

### 5.8 エラー8: 文字が見えない

**症状**: 商品カードの文字が白色で背景も白色なので見えない

**原因**: スタイルで `color` プロパティが設定されていない

**解決方法**:
```typescript
<div style={{ color: '#000' }}>
  <h3 style={{ color: '#000' }}>Item #{index}: {identifier}</h3>
  <p style={{ color: '#000' }}>...</p>
</div>
```

## 6. Supply Chainの動作フロー

### 6.1 全体フロー

```
[管理者] → [1. 商品作成] → [Created (0)]
                                  ↓
[購入者] → [2. 支払い] → [Paid (1)] → [通知表示]
                                  ↓
[管理者] → [3. 配達完了] → [Delivered (2)]
```

### 6.2 各ステップの詳細

#### ステップ1: 商品作成（createItem）

**実行者**: 管理者（オーナー）のみ

**処理**:
1. フロントエンドから `createItem(name, price)` を呼び出し
2. ItemManager が新しい Item コントラクトをデプロイ
3. 商品情報を mapping に保存
4. `SupplyChainStep` イベント発火（step: 0）
5. `itemIndex` をインクリメント

**コントラクト呼び出し**:
```typescript
writeContract({
  address: ITEM_MANAGER_ADDRESS,
  abi: ItemManagerABI.abi,
  functionName: 'createItem',
  args: [itemName, BigInt(cost)],
})
```

#### ステップ2: 支払い（receive → triggerPayment）

**実行者**: 誰でも（購入者）

**処理**:
1. Item コントラクトのアドレスにETHを送信
2. Item の `receive()` 関数が自動実行
3. 金額と状態をチェック
4. ItemManager の `triggerPayment()` を呼び出し
5. ステータスを Paid (1) に更新
6. `SupplyChainStep` イベント発火（step: 1）
7. フロントエンドが通知を表示

**コマンド例**:
```bash
cast send <ItemAddress> --value <priceInWei> --private-key <your-key>
```

#### ステップ3: 配達完了（triggerDelivery）

**実行者**: 管理者（オーナー）のみ

**処理**:
1. ItemManager の `triggerDelivery(index)` を呼び出し
2. ステータスが Paid であることを確認
3. ステータスを Delivered (2) に更新
4. `SupplyChainStep` イベント発火（step: 2）
5. フロントエンドで青色背景に変更

**コマンド例**:
```bash
cast send <ItemManagerAddress> "triggerDelivery(uint256)" <index> --private-key <owner-key>
```

## 7. Wagmi v2の重要概念

### 7.1 フックベースのAPI

Wagmi v2では、すべての操作がReactフックを通じて実行されます。

**主要フック一覧**:

| フック | 用途 | 戻り値 |
|--------|------|--------|
| `useAccount` | アカウント情報取得 | `{ address, isConnected }` |
| `useConnect` | ウォレット接続 | `{ connect, connectors }` |
| `useReadContract` | 読み取り専用関数 | `{ data, isLoading, error }` |
| `useWriteContract` | トランザクション送信 | `{ writeContract, data: hash }` |
| `useWaitForTransactionReceipt` | TX完了待機 | `{ isLoading, isSuccess }` |
| `useWatchContractEvent` | イベント監視 | `void` |

### 7.2 型安全性

Wagmi + Viemは厳密な型チェックを提供します。

**アドレス型の例**:
```typescript
// ✅ 正しい
const address = '0x...' as `0x${string}`

// ❌ エラー: 型が一致しない
const address = '0x...'
```

**BigInt型の例**:
```typescript
// ✅ 正しい
args: [BigInt(100)]

// ❌ エラー: number型は不可
args: [100]
```

### 7.3 リアクティブなデータ更新

Wagmiは自動的にデータを更新します。

**例**: ブロックチェーンの状態が変わると、自動的に再レンダリング
```typescript
const { data: itemIndex } = useReadContract({
  address: ITEM_MANAGER_ADDRESS,
  abi: ItemManagerABI.abi,
  functionName: 'itemIndex',
})

// itemIndexが変わると、コンポーネントが自動的に再レンダリング
```

**手動更新**:
```typescript
const { data, refetch } = useReadContract({...})

// 明示的に再取得
refetch()
```

## 8. 学習のポイント

### 8.1 習得した技術

1. **Solidity**:
   - 構造体とenumの使用
   - イベントの発火と監視
   - コントラクト間の通信（call）
   - receive/fallback関数
   - 修飾子（modifier）による権限管理

2. **Foundry**:
   - プロジェクト構造
   - コントラクトのコンパイル（`forge build`）
   - テストの実行（`forge test`）
   - デプロイ（`forge script`）
   - Anvil（ローカルノード）の使用

3. **React + TypeScript**:
   - 関数コンポーネント
   - フック（useState, useEffect）
   - 条件付きレンダリング
   - 型アノテーション

4. **Wagmi + Viem**:
   - Wagmi v2のフックAPI
   - コントラクト読み取り（useReadContract）
   - トランザクション送信（useWriteContract）
   - イベント監視（useWatchContractEvent）
   - MetaMask連携（useConnect, useAccount）

5. **開発ツール**:
   - Vite（高速開発サーバー）
   - npm/yarn（パッケージ管理）
   - cast（コマンドライン操作）

### 8.2 設計パターン

1. **Factory パターン**: ItemManagerが複数のItemを生成
2. **Callback パターン**: ItemがItemManagerを呼び戻す
3. **Event-Driven アーキテクチャ**: イベントでUI更新
4. **状態機械（State Machine）**: 商品の状態遷移を管理

### 8.3 ベストプラクティス

1. **権限管理**:
   - 重要な操作は `onlyOwner` で保護
   - 内部呼び出しの検証（`require(msg.sender == address(item))`）

2. **ガス最適化**:
   - 状態変数の適切な使用
   - イベントを活用した情報記録

3. **セキュリティ**:
   - 再入攻撃対策（状態更新 → 外部呼び出し）
   - 入力検証（require文）
   - 部分払いの禁止

4. **ユーザビリティ**:
   - リアルタイム通知
   - わかりやすいステータス表示
   - トランザクション完了の明示

## 9. まとめ

### 9.1 プロジェクトの成果

このプロジェクトでは、以下を実現しました:

1. ✅ Solidity でSupply Chain管理コントラクトを実装
2. ✅ Foundry でテスト・デプロイ
3. ✅ React + TypeScript でフロントエンド構築
4. ✅ Wagmi v2 でブロックチェーンとの連携
5. ✅ MetaMask でウォレット接続
6. ✅ リアルタイムイベント監視
7. ✅ 完全な供給チェーンフロー（作成→支払い→配達）

### 9.2 今後の拡張案

1. **UI改善**:
   - ボタンで支払い・配達完了を実行
   - より洗練されたデザイン
   - ローディング表示の追加

2. **機能追加**:
   - 商品画像のアップロード（IPFS連携）
   - 配送トラッキング
   - 複数の購入者への対応
   - 返金機能

3. **セキュリティ強化**:
   - ロールベースアクセス制御（RBAC）
   - マルチシグウォレット
   - タイムロック

4. **テストネット・メインネットへの展開**:
   - Sepolia テストネットへのデプロイ
   - 環境変数の切り替え機構
   - ガス代の最適化

### 9.3 学習リソース

- **Wagmi Documentation**: https://wagmi.sh/
- **Viem Documentation**: https://viem.sh/
- **Foundry Book**: https://book.getfoundry.sh/
- **Solidity Documentation**: https://docs.soliditylang.org/

### 9.4 最後に

このプロジェクトを通じて、モダンなEthereum DApp開発の全体像を理解できました。特に、Wagmi v2 + Viem + React の組み合わせは、型安全性が高く、開発体験が優れています。

引き続き、より複雑なDAppの開発に挑戦してみましょう！
