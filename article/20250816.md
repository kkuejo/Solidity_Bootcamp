# Solidity基礎学習 - Address型、MsgSender、View/Pure関数

**日付**: 2025年8月16日  
**学習内容**: アドレス型、メッセージ送信者、関数の種類とガスコストについて

## 1. Address型の学習

### 005_Address.solの概要
Ethereumのアドレスを扱うための`address`型について学習します。Solidity特有の型で、Ethereumの20バイトアドレスを表現します。

### 重要なポイント

#### Address型の基本
```solidity
contract ExampleAddress {
    // address型はSolidity特有の型で、Ethereumの20バイトのアドレスを表す
    address public someAddress;
    
    function setSomeAddress(address _someAddress) public {
        someAddress = _someAddress;
    }
}
```

**Address型の特徴：**
- **20バイト**の固定長データ
- **16進数**で表現（0xで始まる）
- **デフォルト値**: ゼロアドレス（0x0000000000000000000000000000000000000000）
- **値型**：直接比較可能

#### アドレスのバランス取得
```solidity
function getAddressBalance() public view returns(uint) {
    return someAddress.balance;  // アドレスのバランスを返す
}
```

**バランスの単位：**
- **WEI**単位で返される
- **1 ETH = 10^18 WEI**
- スマートコントラクト内では**WEI**を使用することが多い

**重要なポイント：**
- アドレス型は**値型**なので直接比較可能
- バランスは**読み取り専用**
- ゼロアドレスは**無効なアドレス**として扱われる

## 2. MsgSenderの学習

### 006_MsgSender.solの概要
`msg.sender`について学習します。これは関数を呼び出したアドレスを表す重要なグローバル変数です。

### 重要なポイント

#### MsgSenderの基本概念
```solidity
contract ExampleMsgSender {
    address public someAddress;
    
    function updateSomeAddress() public {
        someAddress = msg.sender;  // 関数を呼び出したアドレスを保存
    }
}
```

**MsgSenderの動作：**
- **直接呼び出し**: アカウントから直接呼び出した場合、`msg.sender`はそのアカウントのアドレス
- **間接呼び出し**: 他のコントラクトを経由して呼び出した場合、`msg.sender`は呼び出しを行ったコントラクトのアドレス

#### 呼び出しパターンの例
```solidity
contract CallPatternExample {
    address public caller;
    
    function directCall() public {
        // 直接呼び出しの場合
        caller = msg.sender;  // 呼び出し元のアカウントアドレス
    }
    
    function indirectCall() public {
        // 間接呼び出しの場合
        caller = msg.sender;  // 呼び出しを行ったコントラクトのアドレス
    }
}
```

**重要なポイント：**
- `msg.sender`は**常に現在の呼び出し元**を表す
- **直接・間接**の呼び出しで値が変わる
- **セキュリティ**の観点で重要な変数

## 3. View/Pure関数の詳細学習

### 007_ViewPure.solの概要
Solidityの3種類の関数（Writing function、View function、Pure function）について学習します。それぞれの特徴とガスコストの違いを理解します。

### 重要なポイント

#### 関数の種類

**1. Writing Function（書き込み関数）：**
```solidity
function setMyStorageVariable(uint _newVar) public returns(uint) {
    myStorageVariable = _newVar;  // 状態変数を変更
    return _newVar;
}
```

**特徴：**
- ブロックチェーンの**状態を変更**する
- **ガスコストが高い**
- トランザクションとして**実行**される
- 状態変数を更新する場合に使用

**2. View Function（読み取り関数）：**
```solidity
function getMyStorageVariable() public view returns(uint) {
    return myStorageVariable;  // 状態変数を読み取り
}
```

**特徴：**
- ブロックチェーンの**状態を読み取り**のみ
- 状態を**変更しない**
- **ガスコストは中程度**
- 状態変数や他のコントラクトの状態を参照
- **外部呼び出し**はガスコストなし、**内部呼び出し**はガスコストあり

**3. Pure Function（純粋関数）：**
```solidity
function getAddition(uint a, uint b) public pure returns(uint) {
    return a + b;  // パラメータのみ使用
}
```

**特徴：**
- ブロックチェーンの**状態を読み取らない**
- 状態を**変更しない**
- **入力パラメータのみ**を使用
- **ガスコストが低い**
- 状態変数に依存しない場合に使用
- **外部呼び出し**はガスコストなし、**内部呼び出し**はガスコストあり

#### ガスコストの比較

**ガスコストの特徴：**
```solidity
contract GasCostComparison {
    uint public value = 100;
    
    // Writing function: 高ガスコスト
    function updateValue(uint _newValue) public {
        value = _newValue;  // 状態変更 → ガスコスト高
    }
    
    // View function: 中ガスコスト
    function getValue() public view returns (uint) {
        return value;  // 状態読み取り → ガスコスト中
    }
    
    // Pure function: 低ガスコスト
    function calculate(uint _a, uint _b) public pure returns (uint) {
        return _a + _b;  // 計算のみ → ガスコスト低
    }
}
```

**ガスコストの順序：**
1. **Writing function**: 最も高い（状態変更のため）
2. **View function**: 中程度（状態読み取りのため）
3. **Pure function**: 最も低い（計算のみのため）

#### 外部呼び出し vs 内部呼び出し

**ガスコストの違い：**
```solidity
contract CallComparison {
    uint public value = 0;
    
    function externalCall() external {
        // 外部呼び出し: ガスコストなし（呼び出し元には）
        externalContract.someFunction();
    }
    
    function internalCall() public {
        // 内部呼び出し: ガスコストあり
        internalHelper();
    }
    
    function internalHelper() internal {
        value++;  // 状態変更
    }
}
```

**重要なポイント：**
- **外部呼び出し**: 呼び出し元には直接のガスコストなし
- **内部呼び出し**: 呼び出し元にガスコストが加算される
- 外部呼び出しのガスコストは**呼び出される側**で発生

## 4. 学習のポイント

### Address型の理解
1. **20バイトの固定長**アドレス型の特徴を理解する
2. **ゼロアドレス**の意味と使用方法を習得する
3. **バランス取得**の方法と単位（WEI）を理解する

### MsgSenderの理解
1. **直接呼び出し**と**間接呼び出し**の違いを理解する
2. **呼び出し元の識別**方法を習得する
3. **セキュリティ**の観点での重要性を理解する

### View/Pure関数の理解
1. **3種類の関数**の特徴と使い分けを習得する
2. **ガスコスト**の違いを理解する
3. **外部呼び出し**と**内部呼び出し**のガスコストの違いを理解する

### ガスコストの最適化
- 適切な関数の種類を選択する
- 状態変更が必要ない場合はView/Pure関数を使用する
- 外部呼び出しと内部呼び出しの使い分けを理解する

## 5. 実用的な応用

### Address型の活用
```solidity
contract AddressUtility {
    mapping(address => uint) public balances;
    
    function transfer(address _to, uint _amount) public {
        require(_to != address(0), "Invalid recipient");  // ゼロアドレスチェック
        require(balances[msg.sender] >= _amount, "Insufficient balance");
        
        balances[msg.sender] -= _amount;
        balances[_to] += _amount;
    }
    
    function getBalance(address _user) public view returns (uint) {
        return _user.balance;  // アドレスのバランス取得
    }
}
```

### MsgSenderの活用
```solidity
contract AccessControl {
    address public owner;
    
    constructor() {
        owner = msg.sender;  // デプロイ時のアドレスを保存
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner can call this function");
        _;
    }
    
    function updateOwner(address _newOwner) public onlyOwner {
        owner = _newOwner;
    }
}
```

### View/Pure関数の活用
```solidity
contract FunctionOptimization {
    uint public totalSupply = 1000000;
    mapping(address => uint) public balances;
    
    // View function: 状態読み取り
    function getTotalSupply() public view returns (uint) {
        return totalSupply;
    }
    
    function getUserBalance(address _user) public view returns (uint) {
        return balances[_user];
    }
    
    // Pure function: 計算のみ
    function calculatePercentage(uint _amount, uint _percentage) 
        public pure returns (uint) {
        return _amount * _percentage / 100;
    }
    
    // Writing function: 状態変更
    function mint(address _to, uint _amount) public {
        totalSupply += _amount;
        balances[_to] += _amount;
    }
}
```

## 6. 今後の学習に向けて

これらの概念を理解することで、より複雑で実用的なスマートコントラクトの作成に進むことができます。次は、配列、マッピング、構造体、イベント、修飾子などの高度な概念について学習していきましょう。

**重要な概念：**
- アドレス型とメッセージ送信者の理解
- 関数の種類とガスコストの最適化
- 外部呼び出しと内部呼び出しの使い分け
- セキュリティを考慮したコントラクト設計

**次の学習項目：**
- 配列とマッピングの操作
- 構造体とカスタムデータ型
- イベントとログ
- 修飾子とアクセス制御
- エラーハンドリングと例外処理

---

**参考**: 
- [Solidity公式ドキュメント](https://docs.soliditylang.org/)
- [Ethereum開発者リソース](https://ethereum.org/developers/)
- [Solidity 0.8.0 変更点](https://docs.soliditylang.org/en/v0.8.0/080-breaking-changes.html)
