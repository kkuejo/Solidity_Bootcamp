# プライベートPoSネットワークでのJSON-RPC APIの実践

**日付**: 2025年12月8日
**学習内容**: GethとPrysmで構築したプライベートPoSネットワークにおけるJSON-RPC APIとBeacon Chain APIの使用方法、アカウント管理、各種情報の取得方法

## 1. 学習の背景と目的

### 1.1 前回の学習内容

2025年12月3日〜4日の学習では、以下を実施しました：

1. **GethとPrysmを使用したプライベートPoSネットワークの構築**
2. **config.yamlの正しい設定によるGenesis Time問題の解決**
3. **継続的なブロック生成の実現**

これにより、完全に動作するプライベートPoSネットワークが構築できました。

### 1.2 本学習の目的

構築したプライベートPoSネットワークを実際に**操作**し、以下を習得します：

1. **JSON-RPC APIを使用したGethとの対話**
2. **アカウントの作成と管理**
3. **ブロックチェーン情報の取得**
4. **Beacon Chain API（PoS特有）の使用**
5. **バリデータ情報の確認**

### 1.3 Ethereum APIアーキテクチャの理解

**PoSネットワークにおける2つのAPIレイヤー**:

```
┌─────────────────────────────────────────────────────┐
│        Ethereum PoS Network APIs                   │
├─────────────────────────────────────────────────────┤
│                                                     │
│  ┌───────────────────────────────────────────┐    │
│  │   Beacon Chain API (Prysm)               │    │
│  │   http://localhost:3500                   │    │
│  │   --------------------------------         │    │
│  │   - バリデータ情報                        │    │
│  │   - スロット/エポック情報                  │    │
│  │   - 同期状態                             │    │
│  │   - コンセンサスレイヤーの状態             │    │
│  └───────────────────────────────────────────┘    │
│                                                     │
│  ┌───────────────────────────────────────────┐    │
│  │   JSON-RPC API (Geth)                    │    │
│  │   http://localhost:8545                   │    │
│  │   IPC: execution/data/geth.ipc            │    │
│  │   --------------------------------         │    │
│  │   - アカウント管理                        │    │
│  │   - トランザクション送信                   │    │
│  │   - ブロック情報                          │    │
│  │   - 残高確認                             │    │
│  │   - スマートコントラクト実行               │    │
│  └───────────────────────────────────────────┘    │
│                                                     │
└─────────────────────────────────────────────────────┘
```

**各APIの役割**:

| API | エンドポイント | 用途 |
|-----|-------------|------|
| **JSON-RPC API** | http://localhost:8545<br>execution/data/geth.ipc | Ethereum本来の機能（トランザクション、スマートコントラクト等） |
| **Beacon Chain API** | http://localhost:3500 | PoS特有の機能（バリデータ、スロット、証明等） |

**簡単に言うと**:

- **JSON-RPC API（Geth）** = 「銀行の窓口」
  - お金（ETH）を送る
  - 残高を確認する
  - スマートコントラクト（自動契約）を実行する
  - **例**: 「AさんからBさんに1 ETH送りたい」というリクエストを受け付ける

- **Beacon Chain API（Prysm）** = 「銀行の管理部門」
  - 誰が次の処理を担当するか決める（バリデータのスケジュール）
  - 全体の同期状態を確認する
  - バリデータの報酬を管理する
  - **例**: 「次はバリデータ0番がブロックを作る番です」という情報を提供

- どちらのAPIも「ブロックチェーンの情報を見る・操作する窓口」だが、見える情報が違う

## 2. JSON-RPC APIの基本

### 2.1 JSON-RPCとは

**JSON-RPC**（JSON Remote Procedure Call）:
- HTTPやWebSocketを使用してリモートのメソッドを呼び出すプロトコル
- JSON形式でリクエスト・レスポンスを交換
- Ethereumノードとの通信標準

**もっと簡単に言うと**:
- **RPC（Remote Procedure Call）** = 遠隔地にあるコンピュータの機能を呼び出すこと
- **JSON** = データをやり取りする形式（読みやすいテキスト形式）
- **例**: レストランで注文するようなもの
  - あなた（クライアント）: 「ブロック番号を教えて」（リクエスト）
  - Geth（サーバー）: 「現在のブロック番号は45です」（レスポンス）

**基本的なリクエスト形式**:

```json
{
  "jsonrpc": "2.0",           // バージョン（決まり文句）
  "method": "メソッド名",      // 何をしたいか（例: eth_blockNumber）
  "params": [パラメータ],      // 追加の情報（例: アドレス）
  "id": 1                     // リクエストの識別番号
}
```

**レスポンス形式**:

```json
{
  "jsonrpc": "2.0",           // バージョン（決まり文句）
  "id": 1,                    // どのリクエストへの返答か
  "result": "結果"            // 答え（例: ブロック番号）
}
```

### 2.2 接続方法

Gethには3つの接続方法があります：

**どれを使えばいい？**
- **初心者**: まずはHTTP接続から始めよう（一番シンプル）
- **リアルタイム監視が必要**: WebSocket接続
- **同じPC内で最速**: IPC接続

#### 2.2.1 HTTP接続

```bash
# curlを使用した直接アクセス
curl -X POST -H "Content-Type: application/json" \
  --data '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}' \
  http://localhost:8545
```

**メリット**:
- ✅ シンプルで理解しやすい
- ✅ ファイアウォール越しにアクセス可能
- ✅ 任意のプログラミング言語から利用可能

**デメリット**:
- ❌ リアルタイム通知（サブスクリプション）が使えない

#### 2.2.2 WebSocket接続

```bash
# wscat（WebSocketクライアント）を使用
wscat -c ws://localhost:8546
```

**メリット**:
- ✅ リアルタイム通知（新しいブロック、イベント等）が受信可能
- ✅ 双方向通信

**デメリット**:
- ❌ HTTP接続より複雑

#### 2.2.3 IPC接続（Unix Domain Socket）

```bash
# geth attachコマンドを使用
geth attach execution/data/geth.ipc

# または
geth attach ipc:execution/data/geth.ipc
```

**メリット**:
- ✅ 最も高速（ローカルソケット通信）
- ✅ セキュア（ローカルファイルシステム経由）
- ✅ 対話型コンソールが使える

**デメリット**:
- ❌ 同じマシン内でのみ使用可能

### 2.3 接続可能なAPIモジュール

Geth起動時に`--http.api`オプションで指定：

```bash
--http.api eth,net,web3,engine,admin
```

| モジュール | 説明 | 主な用途 |
|----------|------|---------|
| `eth` | Ethereum関連 | ブロック情報、トランザクション、残高確認 |
| `net` | ネットワーク関連 | ピア情報、ネットワークID |
| `web3` | Web3関連 | クライアントバージョン、SHA3ハッシュ |
| `engine` | Engine API | Beacon ChainとGethの通信（通常は内部使用） |
| `admin` | 管理機能 | ピア管理、ノード情報 |
| `personal` | アカウント管理 | アカウント作成、ロック解除（非推奨） |
| `txpool` | トランザクションプール | 保留中のトランザクション確認 |
| `debug` | デバッグ機能 | トレース、スタックトレース |

**セキュリティ上の注意**:
- `personal`, `admin`, `debug`は本番環境では公開しない
- HTTPで公開する場合は必ず`--http.corsdomain`や`--http.vhosts`で制限する

## 3. アカウント管理

### 3.1 アカウントの作成

#### 3.1.1 コマンドラインでの作成（推奨）

```bash
# パスワードファイルを作成
echo 'password123' > /tmp/account_password.txt

# アカウントを作成
geth account new --datadir execution/data --password /tmp/account_password.txt
```

**出力例**:
```
Your new key was generated

Public address of the key:   0x8B9A659aF5964720820C9A2398100677AE0AC9b0
Path of the secret key file: execution/data/keystore/UTC--2025-12-08T22-47-40.515600541Z--8b9a659af5964720820c9a2398100677ae0ac9b0

- You can share your public address with anyone. Others need it to interact with you.
- You must NEVER share the secret key with anyone! The key controls access to your funds!
- You must BACKUP your key file! Without the key, it's impossible to access account funds!
- You must REMEMBER your password! Without the password, it's impossible to decrypt the key!
```

**重要な要素**:

| 項目 | 説明 | 扱い |
|------|------|------|
| **Public Address** | 0x8B9A65... | 公開OK（他者がETHを送信する際に使用） |
| **Secret Key File** | execution/data/keystore/UTC--... | **絶対に秘密！バックアップ必須** |
| **Password** | password123 | **絶対に秘密！忘れたら復元不可** |

**銀行口座に例えると**:
- **Public Address（公開アドレス）** = 「銀行口座番号」
  - 誰にでも教えてOK
  - 人にお金を送ってもらうときに必要
  - **例**: 「私の口座は0x8B9A65...です」と伝えられる

- **Secret Key File（秘密鍵ファイル）** = 「銀行のキャッシュカード」
  - 絶対に他人に渡してはダメ
  - これがないとお金を動かせない
  - 盗まれたら全財産を失う可能性がある

- **Password（パスワード）** = 「キャッシュカードの暗証番号」
  - キャッシュカードと一緒に管理してはダメ
  - 忘れたらキャッシュカードが使えなくなる（復元不可）
  - 他人に教えてはダメ

#### 3.1.2 アカウントリストの確認

```bash
# JSON-RPC経由で確認
curl -s -X POST -H "Content-Type: application/json" \
  --data '{"jsonrpc":"2.0","method":"eth_accounts","params":[],"id":1}' \
  http://localhost:8545
```

**出力例**:
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": [
    "0x8b9a659af5964720820c9a2398100677ae0ac9b0",
    "0x937a430ef97920ea2fefa5bc71c11db6c6cae540"
  ]
}
```

#### 3.1.3 keystoreファイルの構造

作成されたアカウントは**keystore**ディレクトリに保存されます：

```bash
ls -l execution/data/keystore/
```

**出力例**:
```
-rw------- 1 user user 491 Dec  8 23:47 UTC--2025-12-08T22-47-40.515600541Z--8b9a659af5964720820c9a2398100677ae0ac9b0
```

**keystoreファイルの中身**（JSON形式）:

```json
{
  "address": "8b9a659af5964720820c9a2398100677ae0ac9b0",
  "crypto": {
    "cipher": "aes-128-ctr",
    "ciphertext": "...",
    "cipherparams": { "iv": "..." },
    "kdf": "scrypt",
    "kdfparams": { ... },
    "mac": "..."
  },
  "id": "...",
  "version": 3
}
```

**セキュリティ機構**:
- 秘密鍵はパスワードで**暗号化**されて保存
- `scrypt`という強力なキー導出関数を使用
- パスワードなしでは秘密鍵を復号できない

### 3.2 personal APIの非推奨化

以前は`personal.newAccount()`や`personal.unlockAccount()`が使用されていましたが、現在は**非推奨**です。

**理由**:
1. セキュリティリスク（HTTPで平文パスワードを送信）
2. アカウント管理は外部ツール（Clef、MetaMask等）に移行

**代替方法**:
- **Clef**: Geth公式のアカウント管理・署名ツール
- **MetaMask**: ブラウザ拡張機能
- **Hardhat/Foundry**: 開発環境での自動管理

## 4. JSON-RPC操作の実践

### 4.1 ブロック番号の取得

```bash
curl -s -X POST -H "Content-Type: application/json" \
  --data '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}' \
  http://localhost:8545
```

**レスポンス**:
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": "0x2d"  // 16進数（0x2d = 45）
}
```

**10進数に変換**:
```bash
curl -s -X POST -H "Content-Type: application/json" \
  --data '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}' \
  http://localhost:8545 | python3 -c "import sys, json; data = json.load(sys.stdin); print('Block Number:', int(data['result'], 16))"
```

**出力**:
```
Block Number: 45
```

### 4.2 残高の確認

```bash
curl -s -X POST -H "Content-Type: application/json" \
  --data '{
    "jsonrpc":"2.0",
    "method":"eth_getBalance",
    "params":["0x8b9a659af5964720820c9a2398100677ae0ac9b0", "latest"],
    "id":1
  }' \
  http://localhost:8545
```

**パラメータ**:
1. アドレス: `0x8b9a659af5964720820c9a2398100677ae0ac9b0`
2. ブロック: `latest`（最新）、`earliest`（最古）、または16進数のブロック番号

**レスポンス**:
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": "0x0"  // 0 Wei（残高なし）
}
```

**Wei単位について**:

Ethereumでは以下の単位が使用されます：

| 単位 | Wei換算 | 説明 |
|------|---------|------|
| Wei | 1 | 最小単位 |
| Kwei (babbage) | 10³ | 1,000 Wei |
| Mwei (lovelace) | 10⁶ | 1,000,000 Wei |
| Gwei (shannon) | 10⁹ | 1,000,000,000 Wei（ガス価格でよく使用） |
| Szabo | 10¹² | 1,000,000,000,000 Wei |
| Finney | 10¹⁵ | 1,000,000,000,000,000 Wei |
| **Ether** | 10¹⁸ | 1,000,000,000,000,000,000 Wei |

**例**: 1 ETH = 1,000,000,000,000,000,000 Wei

**お金の単位に例えると**:
- **Wei** = 「銭（せん）」（最小単位）
- **Gwei** = 「円」（ガス代の支払いでよく使う）
- **Ether（ETH）** = 「万円」（大きな金額）

日本円で言うと：
- 1円 = 100銭
- 1万円 = 1,000,000銭

Ethereumで言うと：
- 1 Gwei = 1,000,000,000 Wei
- 1 ETH = 1,000,000,000 Gwei = 1,000,000,000,000,000,000 Wei

**なぜこんなに細かい？**
- 小さな金額（例: 0.0001 ETH）も正確に扱うため
- ガス代（手数料）の計算を精密にするため
- プログラムでは整数で計算する方が正確だから（小数点の誤差が出ない）

### 4.3 ブロック情報の取得

```bash
curl -s -X POST -H "Content-Type: application/json" \
  --data '{
    "jsonrpc":"2.0",
    "method":"eth_getBlockByNumber",
    "params":["latest", false],
    "id":1
  }' \
  http://localhost:8545 | python3 -c "import sys, json; print(json.dumps(json.load(sys.stdin), indent=2))"
```

**パラメータ**:
1. ブロック番号: `latest`, `earliest`, `pending`, または16進数
2. トランザクション詳細: `true`（全詳細）、`false`（ハッシュのみ）

**レスポンス例**:
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "number": "0x2d",
    "hash": "0xd0753eb99a65fc4692794d873e775fa730e5f0b56a775413b4ed9b4b4db58461",
    "parentHash": "0x...",
    "timestamp": "0x67562f88",
    "difficulty": "0x0",
    "gasLimit": "0x8000000",
    "gasUsed": "0x0",
    "miner": "0x0000000000000000000000000000000000000000",
    "transactions": []
  }
}
```

**重要なフィールド**:

| フィールド | 説明 |
|----------|------|
| `number` | ブロック番号 |
| `hash` | ブロックハッシュ（ブロックの一意識別子） |
| `parentHash` | 親ブロックのハッシュ（チェーン構造） |
| `timestamp` | ブロック生成時刻（Unix時間） |
| `gasLimit` | ブロックのガス上限 |
| `gasUsed` | 実際に使用されたガス |
| `miner` | ブロック提案者（PoSでは0x0...0） |
| `transactions` | トランザクションリスト |

### 4.4 同期状態の確認

```bash
curl -s -X POST -H "Content-Type: application/json" \
  --data '{"jsonrpc":"2.0","method":"eth_syncing","params":[],"id":1}' \
  http://localhost:8545
```

**完全同期している場合**:
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": false
}
```

**同期中の場合**:
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "startingBlock": "0x0",
    "currentBlock": "0x64",
    "highestBlock": "0x12c"
  }
}
```

### 4.5 ネットワーク情報の取得

```bash
# ネットワークID
curl -s -X POST -H "Content-Type: application/json" \
  --data '{"jsonrpc":"2.0","method":"net_version","params":[],"id":1}' \
  http://localhost:8545
```

**レスポンス**:
```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": "32382"  // 私たちのプライベートネットワークのID
}
```

**主要なネットワークID**:

| ネットワーク | ID |
|------------|-----|
| Ethereum Mainnet | 1 |
| Goerli Testnet | 5 |
| Sepolia Testnet | 11155111 |
| **私たちのプライベートネット** | **32382** |

## 5. Beacon Chain API（PoS特有）

PoSネットワークでは、Gethの**JSON-RPC API**に加えて、Prysmの**Beacon Chain API**も使用できます。

### 5.1 Beacon Chain APIとは

**Beacon Chain API**:
- Ethereumの公式REST API仕様に準拠
- コンセンサスレイヤー（PoS）の情報を取得
- HTTPのGETリクエストで簡単にアクセス可能

**エンドポイント**: `http://localhost:3500`

**APIドキュメント**: https://ethereum.github.io/beacon-APIs/

### 5.2 同期状態の確認

```bash
curl -s http://localhost:3500/eth/v1/node/syncing | python3 -c "import sys, json; print(json.dumps(json.load(sys.stdin), indent=2))"
```

**レスポンス**:
```json
{
  "data": {
    "head_slot": "47",
    "sync_distance": "0",
    "is_syncing": false,
    "is_optimistic": false,
    "el_offline": false
  }
}
```

**フィールドの説明**:

| フィールド | 説明 |
|----------|------|
| `head_slot` | 現在のヘッドスロット番号 |
| `sync_distance` | 同期が必要な残りスロット数 |
| `is_syncing` | 同期中かどうか（false = 完全同期） |
| `is_optimistic` | オプティミスティック同期中かどうか |
| `el_offline` | 実行レイヤー（Geth）がオフラインかどうか |

### 5.3 バリデータ情報の取得

```bash
curl -s http://localhost:3500/eth/v1/beacon/states/head/validators | python3 -c "import sys, json; data = json.load(sys.stdin); print('Total Validators:', len(data.get('data', [])))"
```

**出力**:
```
Total Validators: 1
```

**詳細情報を確認**:
```bash
curl -s http://localhost:3500/eth/v1/beacon/states/head/validators | python3 -c "import sys, json; print(json.dumps(json.load(sys.stdin)['data'][0], indent=2))"
```

**レスポンス**:
```json
{
  "index": "0",
  "balance": "32001957509",
  "status": "active_ongoing",
  "validator": {
    "pubkey": "0xa99a76ed7796f7be22d5b7e85deeb7c5677e88e511e0b337618f8c4eb61349b4bf2d153f649f7b53359fe8b94a38e44c",
    "withdrawal_credentials": "0x00fad2a6bfb0e7f1f0f45460944fbd8dfa7f37da06a4d13b3983cc90bb46963b",
    "effective_balance": "32000000000",
    "slashed": false,
    "activation_eligibility_epoch": "0",
    "activation_epoch": "0",
    "exit_epoch": "18446744073709551615",
    "withdrawable_epoch": "18446744073709551615"
  }
}
```

**バリデータのステータス**:

| ステータス | 説明 |
|----------|------|
| `pending_initialized` | デポジット受領済み、アクティベーション待ち |
| `pending_queued` | アクティベーション待機列 |
| `active_ongoing` | **アクティブ（現在証明中）** |
| `active_exiting` | 退出プロセス中 |
| `active_slashed` | スラッシュされた（不正行為） |
| `exited_unslashed` | 正常に退出 |
| `exited_slashed` | スラッシュ後退出 |
| `withdrawal_possible` | 引き出し可能 |
| `withdrawal_done` | 引き出し完了 |

**バリデータの残高**:
- `balance`: 32001957509 Gwei = 32.001957509 ETH
- `effective_balance`: 32000000000 Gwei = 32 ETH（報酬計算用）

報酬が少しずつ増加していることがわかります！

**分かりやすく説明すると**:

- **balance（実際の残高）**: 32.001957509 ETH
  - バリデータが持っている実際のETH
  - ブロックを作ったり証明したりすると、少しずつ増える
  - **例**: 銀行口座の実際の残高

- **effective_balance（有効残高）**: 32 ETH
  - 報酬の計算に使われる残高
  - 32 ETHでキャップ（上限）されている
  - 実際の残高が32.001 ETHでも、報酬計算では32 ETHとして扱われる
  - **例**: ポイントカードの「ポイント計算に使える金額」

- **status: active_ongoing** = 「現在アクティブに働いています」
  - バリデータが正常に動作中
  - ブロックの提案や証明を行っている
  - 報酬を獲得し続けている状態

**なぜ報酬がもらえる？**
- ブロックを正しく提案する → 報酬
- 他のバリデータのブロックを証明する → 報酬
- ネットワークの安全性を守る → 報酬
- **例**: 銀行の金利のようなもの。ただし、仕事をしないと報酬はもらえない

### 5.4 チェーンヘッド情報の取得

```bash
curl -s http://localhost:3500/eth/v1/beacon/headers/head | python3 -c "import sys, json; data = json.load(sys.stdin); header = data.get('data', {}).get('header', {}).get('message', {}); print('Slot:', header.get('slot')); print('Proposer Index:', header.get('proposer_index')); print('Parent Root:', header.get('parent_root')); print('State Root:', header.get('state_root'))"
```

**出力**:
```
Slot: 48
Proposer Index: 0
Parent Root: 0xd0753eb99a65fc4692794d873e775fa730e5f0b56a775413b4ed9b4b4db58461
State Root: 0x410be17c268f06e3d5a025b1ebb58bcf66e5897c63f9d264c53eb1aa68d50d11
```

**フィールドの説明**:

| フィールド | 説明 |
|----------|------|
| `slot` | 現在のスロット番号（12秒ごとに+1） |
| `proposer_index` | ブロック提案者のバリデータインデックス |
| `parent_root` | 親ブロックのルートハッシュ |
| `state_root` | Beacon Chainの状態ルートハッシュ |

### 5.5 Genesis情報の確認

```bash
curl -s http://localhost:3500/eth/v1/beacon/genesis | python3 -c "import sys, json; data = json.load(sys.stdin).get('data', {}); import datetime; print('Genesis Time:', datetime.datetime.fromtimestamp(int(data.get('genesis_time', 0)))); print('Genesis Validators Root:', data.get('genesis_validators_root'))"
```

**出力**:
```
Genesis Time: 2025-12-08 23:39:15
Genesis Validators Root: 0x2981d7b74aef065bf8a3c448b51251552570aac44015cf00e0077dd30df530b7
```

## 6. 実践例：ブロックチェーン情報の総合確認

**このセクションで学ぶこと**:
- 複数のAPIを組み合わせて、ネットワーク全体の状態を確認する方法
- **例**: 銀行のATMで「残高」「入出金履歴」「カード情報」を一度に表示するようなもの

### 6.1 一括情報取得スクリプト

以下のスクリプトで、ネットワークの状態を一目で確認できます：

**スクリプトの役割**:
- 実行レイヤー（Geth）と合意レイヤー（Beacon Chain）の両方の情報を取得
- **例**: スマートフォンで「WiFi接続状態」「電池残量」「メモリ使用量」を一度に確認するようなもの

```bash
#!/bin/bash

echo "========================================="
echo "  Ethereum Private PoS Network Status  "
echo "========================================="
echo ""

# Geth情報
echo "【Execution Layer (Geth)】"
BLOCK_NUM=$(curl -s -X POST -H "Content-Type: application/json" \
  --data '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}' \
  http://localhost:8545 | python3 -c "import sys, json; data = json.load(sys.stdin); print(int(data['result'], 16))")
echo "  Block Number: $BLOCK_NUM"

NETWORK_ID=$(curl -s -X POST -H "Content-Type: application/json" \
  --data '{"jsonrpc":"2.0","method":"net_version","params":[],"id":1}' \
  http://localhost:8545 | python3 -c "import sys, json; print(json.load(sys.stdin)['result'])")
echo "  Network ID: $NETWORK_ID"

ACCOUNTS=$(curl -s -X POST -H "Content-Type: application/json" \
  --data '{"jsonrpc":"2.0","method":"eth_accounts","params":[],"id":1}' \
  http://localhost:8545 | python3 -c "import sys, json; print(len(json.load(sys.stdin)['result']))")
echo "  Accounts: $ACCOUNTS"

echo ""

# Beacon Chain情報
echo "【Consensus Layer (Beacon Chain)】"
curl -s http://localhost:3500/eth/v1/beacon/headers/head | python3 -c "
import sys, json
data = json.load(sys.stdin)
header = data.get('data', {}).get('header', {}).get('message', {})
print(f\"  Current Slot: {header.get('slot')}\")
print(f\"  Proposer Index: {header.get('proposer_index')}\")
"

VALIDATORS=$(curl -s http://localhost:3500/eth/v1/beacon/states/head/validators | python3 -c "import sys, json; print(len(json.load(sys.stdin).get('data', [])))")
echo "  Active Validators: $VALIDATORS"

curl -s http://localhost:3500/eth/v1/beacon/genesis | python3 -c "
import sys, json, datetime
data = json.load(sys.stdin).get('data', {})
genesis_time = int(data.get('genesis_time', 0))
print(f\"  Genesis Time: {datetime.datetime.fromtimestamp(genesis_time)}\")
"

echo ""
echo "========================================="
```

**実行結果例**:
```
=========================================
  Ethereum Private PoS Network Status
=========================================

【Execution Layer (Geth)】
  Block Number: 48
  Network ID: 32382
  Accounts: 2

【Consensus Layer (Beacon Chain)】
  Current Slot: 48
  Proposer Index: 0
  Active Validators: 1
  Genesis Time: 2025-12-08 23:39:15

=========================================
```

### 6.2 ブロック生成の観察

以下のスクリプトで、リアルタイムにブロック生成を観察できます：

**スクリプトの役割**:
- 12秒ごとに新しいブロックが作られる様子を見る
- **例**: 時計の秒針が12秒ごとに「カチッ」と動くのを観察するようなもの
- GethとBeacon Chainが同期して動いていることを確認できる

```bash
#!/bin/bash

echo "Watching block production (Ctrl+C to stop)..."
echo ""

while true; do
  GETH_BLOCK=$(curl -s -X POST -H "Content-Type: application/json" \
    --data '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}' \
    http://localhost:8545 | python3 -c "import sys, json; data = json.load(sys.stdin); print(int(data['result'], 16))")

  BEACON_SLOT=$(curl -s http://localhost:3500/eth/v1/beacon/headers/head | python3 -c "import sys, json; data = json.load(sys.stdin); header = data.get('data', {}).get('header', {}).get('message', {}); print(header.get('slot'))")

  TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')

  echo "[$TIMESTAMP] Geth Block: $GETH_BLOCK | Beacon Slot: $BEACON_SLOT"

  sleep 12
done
```

**出力例**:
```
Watching block production (Ctrl+C to stop)...

[2025-12-08 23:48:00] Geth Block: 48 | Beacon Slot: 48
[2025-12-08 23:48:12] Geth Block: 49 | Beacon Slot: 49
[2025-12-08 23:48:24] Geth Block: 50 | Beacon Slot: 50
[2025-12-08 23:48:36] Geth Block: 51 | Beacon Slot: 51
```

12秒ごとに新しいブロックが生成されていることが確認できます！

## 7. web3.jsでの接続（参考）

実際のDApp開発では、**web3.js**や**ethers.js**といったライブラリを使用します。

**簡単に言うと**:
- **web3.js / ethers.js** = 「プログラムから銀行APIを使うための便利ツール」
- curlコマンドを毎回打つのは面倒 → ライブラリが自動でやってくれる
- **例**: 銀行のATMアプリ（アプリの裏側でAPIを使っている）

### 7.1 web3.jsのインストール

```bash
npm install web3
```

### 7.2 基本的な接続例

```javascript
const Web3 = require('web3');

// Geth（Execution Layer）に接続
const web3 = new Web3('http://localhost:8545');

async function main() {
  // ネットワークIDを取得
  const networkId = await web3.eth.net.getId();
  console.log('Network ID:', networkId);

  // 最新ブロック番号を取得
  const blockNumber = await web3.eth.getBlockNumber();
  console.log('Block Number:', blockNumber);

  // アカウントリストを取得
  const accounts = await web3.eth.getAccounts();
  console.log('Accounts:', accounts);

  // 残高を取得（Wei単位）
  if (accounts.length > 0) {
    const balance = await web3.eth.getBalance(accounts[0]);
    console.log('Balance (Wei):', balance);

    // ETH単位に変換
    const balanceEth = web3.utils.fromWei(balance, 'ether');
    console.log('Balance (ETH):', balanceEth);
  }
}

main().catch(console.error);
```

**出力例**:
```
Network ID: 32382
Block Number: 52
Accounts: [
  '0x8b9a659af5964720820c9a2398100677ae0ac9b0',
  '0x937a430ef97920ea2fefa5bc71c11db6c6cae540'
]
Balance (Wei): 0
Balance (ETH): 0
```

### 7.3 ethers.jsの例

```javascript
const { ethers } = require('ethers');

// プロバイダーを作成
const provider = new ethers.JsonRpcProvider('http://localhost:8545');

async function main() {
  // ネットワーク情報を取得
  const network = await provider.getNetwork();
  console.log('Chain ID:', network.chainId);

  // ブロック番号を取得
  const blockNumber = await provider.getBlockNumber();
  console.log('Block Number:', blockNumber);

  // ブロック情報を取得
  const block = await provider.getBlock(blockNumber);
  console.log('Latest Block:', {
    number: block.number,
    hash: block.hash,
    timestamp: new Date(block.timestamp * 1000),
    gasUsed: block.gasUsed.toString()
  });
}

main().catch(console.error);
```

## 8. よくある操作とトラブルシューティング

**このセクションで学ぶこと**:
- よくあるエラーとその解決方法
- **例**: 「ATMでカードが使えない」「パスワードが合わない」といったトラブル対処法

### 8.1 personalモジュールが使えない

**症状**:
```
{"jsonrpc":"2.0","id":1,"error":{"code":-32601,"message":"the method personal_newAccount does not exist/is not available"}}
```

**原因**:
- `personal` APIモジュールが有効になっていない
- 最近のGethでは`personal` APIは非推奨

**簡単に言うと**:
- 昔は「APIでアカウント作成」ができた
- 今は「コマンドラインでアカウント作成」が推奨されている
- **例**: 昔は「電話で口座開設」できたが、今は「窓口で手続き」が必要になったようなもの

**解決方法**:

1. **コマンドラインでアカウント作成**（推奨）:
   ```bash
   geth account new --datadir execution/data --password /tmp/password.txt
   ```

2. **Geth起動時にpersonalモジュールを有効化**（非推奨）:
   ```bash
   --http.api eth,net,web3,engine,admin,personal
   ```

### 8.2 IPCソケットが見つからない

**症状**:
```
Fatal: Unable to attach to remote geth: dial unix execution/data/geth.ipc: connect: no such file or directory
```

**原因**:
- Gethが起動していない
- IPCが無効化されている
- パスが間違っている

**簡単に言うと**:
- IPCソケット = 「プログラム同士が会話するための電話回線」
- Gethが起動していない = 「電話機の電源が入っていない」
- パスが間違っている = 「間違った電話番号にかけている」

**解決方法**:

1. **Gethが起動しているか確認**:
   ```bash
   ps aux | grep geth
   ```

2. **IPCソケットの存在を確認**:
   ```bash
   ls -l execution/data/geth.ipc
   ```

3. **正しいパスを指定**:
   ```bash
   geth attach execution/data/geth.ipc
   ```

### 8.3 CORS エラー（ブラウザから接続する場合）

**症状**:
```
Access to fetch at 'http://localhost:8545' from origin 'http://localhost:3000' has been blocked by CORS policy
```

**原因**:
- Gethが異なるオリジンからのリクエストを拒否

**簡単に言うと**:
- CORS = 「別のウェブサイトからのアクセスを制限するセキュリティ機能」
- **例**: 銀行のATMは「その銀行の建物内」からしか使えないようなもの
- ブラウザのWebアプリから接続する場合に必要な設定

**解決方法**:

Geth起動時に`--http.corsdomain`を指定：

```bash
--http.corsdomain "http://localhost:3000"

# または全て許可（開発環境のみ）
--http.corsdomain "*"
```

## 9. セキュリティベストプラクティス

**このセクションで学ぶこと**:
- プライベートネットワークと本番環境の違い
- 大切なお金（ETH）や秘密鍵を守る方法
- **例**: 家の鍵の管理方法（家では気軽に置いておくが、外出時は厳重に管理）

### 9.1 本番環境での注意事項

| 項目 | プライベートネット | 本番環境 |
|------|-----------------|---------|
| `--http.addr` | 0.0.0.0（全て許可） | 127.0.0.1（ローカルのみ） |
| `--http.corsdomain` | "*"（全て許可） | 特定のドメインのみ |
| `--http.api` | eth,net,web3,engine,admin | eth,net,web3のみ |
| `personal` API | 使用可（テスト用） | **絶対に使用しない** |
| パスワード | 簡易的（password123） | 強固な複雑パスワード |
| keystoreバックアップ | ローカルのみ | **複数の安全な場所** |

**簡単に言うと**:

| 設定 | プライベート（練習） | 本番（本物のお金） |
|------|------------------|------------------|
| **アクセス制限** | 誰でもOK（自分しかいない） | 自分だけ（厳重に制限） |
| **パスワード** | 簡単なもの（password123） | 複雑で長いもの |
| **バックアップ** | パソコンに保存 | USBメモリ + クラウド + 紙 |
| **API公開** | 全機能使える | 必要最小限のみ |

**例**:
- **プライベートネット** = 「自宅の練習用金庫」（中身は偽札）
- **本番環境** = 「銀行の貸金庫」（中身は本物のお金）

### 9.2 keystoreの保護

**やるべきこと**:
- ✅ keystoreファイルを定期的にバックアップ
- ✅ バックアップは暗号化して保存
- ✅ パスワードは別の場所に保管
- ✅ ハードウェアウォレット（Ledger等）の使用を検討

**やってはいけないこと**:
- ❌ keystoreファイルをGitHubにコミット
- ❌ パスワードを平文で保存
- ❌ 秘密鍵を他人と共有
- ❌ HTTPSなしでpersonal APIを公開

**簡単に言うと**:

**keystoreファイル** = 「銀行のキャッシュカード」
- 無くしたら → お金が取り出せない
- 盗まれたら → 全財産を失う可能性

**やるべきこと（○）**:
1. **バックアップ** = 「カードのコピーを金庫に保管」
   - USBメモリに保存
   - クラウドストレージ（暗号化して）
   - 紙に印刷して金庫に保管

2. **パスワード分散管理** = 「暗証番号は別の場所にメモ」
   - keystoreとパスワードを同じ場所に置かない
   - パスワードマネージャーを使う

3. **ハードウェアウォレット** = 「銀行の貸金庫」
   - Ledger、Trezorなど
   - 物理的なデバイスで秘密鍵を保護

**やってはいけないこと（×）**:
1. **GitHubにコミット** = 「カードと暗証番号をネットに公開」
   - 全世界の人が見られる
   - 即座にハッキングされる可能性

2. **パスワードを平文保存** = 「暗証番号をカードに書く」
   - keystoreとパスワードが同じ場所にある
   - 両方を盗まれたら終わり

3. **秘密鍵を共有** = 「カードと暗証番号を他人に教える」
   - 信頼していても絶対にダメ
   - 取り返しがつかない

## 10. 学習のまとめ

### 10.1 習得した知識

1. **JSON-RPC APIの基本**:
   - リクエスト・レスポンス形式の理解
   - HTTP、WebSocket、IPC接続の違い
   - 主要なAPIモジュール（eth, net, web3等）

2. **アカウント管理**:
   - コマンドラインでのアカウント作成
   - keystoreファイルの仕組み
   - セキュリティベストプラクティス

3. **基本的なJSON-RPC操作**:
   - ブロック番号の取得（`eth_blockNumber`）
   - 残高確認（`eth_getBalance`）
   - ブロック情報の取得（`eth_getBlockByNumber`）
   - アカウントリスト（`eth_accounts`）
   - ネットワーク情報（`net_version`）

4. **Beacon Chain API（PoS特有）**:
   - 同期状態の確認
   - バリデータ情報の取得
   - スロット/エポック情報
   - Genesis情報の確認

5. **実践的なスクリプト作成**:
   - ネットワーク状態の総合確認スクリプト
   - ブロック生成の監視スクリプト

### 10.2 実践した操作

| 操作 | 使用したAPI | 成功 |
|------|-----------|------|
| HTTP接続の確認 | `eth_blockNumber` | ✅ |
| アカウント作成 | `geth account new` | ✅ |
| アカウントリスト取得 | `eth_accounts` | ✅ |
| 残高確認 | `eth_getBalance` | ✅ |
| ブロック情報取得 | `eth_getBlockByNumber` | ✅ |
| ネットワーク情報 | `net_version` | ✅ |
| Beacon Chain同期状態 | `/eth/v1/node/syncing` | ✅ |
| バリデータ情報 | `/eth/v1/beacon/states/head/validators` | ✅ |
| チェーンヘッド | `/eth/v1/beacon/headers/head` | ✅ |
| Genesis情報 | `/eth/v1/beacon/genesis` | ✅ |

### 10.3 APIアーキテクチャの理解

```
┌─────────────────────────────────────────────────────┐
│      Ethereum PoS Network - 2層構造のAPI           │
├─────────────────────────────────────────────────────┤
│                                                     │
│  【Consensus Layer API】                           │
│  ┌───────────────────────────────────────────┐    │
│  │ Beacon Chain API (Prysm)                 │    │
│  │ http://localhost:3500                     │    │
│  │ --------------------------------          │    │
│  │ ✓ バリデータ情報                         │    │
│  │ ✓ スロット/エポック                      │    │
│  │ ✓ 証明（attestation）                    │    │
│  │ ✓ 同期状態                              │    │
│  └───────────────────────────────────────────┘    │
│             ↕ Engine API (JWT認証)                │
│  【Execution Layer API】                           │
│  ┌───────────────────────────────────────────┐    │
│  │ JSON-RPC API (Geth)                      │    │
│  │ http://localhost:8545                     │    │
│  │ IPC: execution/data/geth.ipc              │    │
│  │ --------------------------------          │    │
│  │ ✓ アカウント管理                         │    │
│  │ ✓ トランザクション                       │    │
│  │ ✓ スマートコントラクト                    │    │
│  │ ✓ ブロック情報                           │    │
│  └───────────────────────────────────────────┘    │
│                                                     │
└─────────────────────────────────────────────────────┘
```

### 10.4 重要なポイント

1. **2つのAPIレイヤー**:
   - **JSON-RPC API（Geth）**: 従来のEthereum機能
   - **Beacon Chain API（Prysm）**: PoS特有の機能

   **簡単に言うと**:
   - **Geth（実行レイヤー）** = 「銀行の窓口」（お金のやり取り、契約の実行）
   - **Prysm（合意レイヤー）** = 「銀行の管理部門」（次に誰が処理を担当するか決める）
   - **なぜ2つ必要？** PoSでは「お金の処理」と「誰が処理するか決める」を分けることで安全性を高めている

2. **接続方法の選択**:
   - **HTTP**: シンプル、汎用的
   - **WebSocket**: リアルタイム通知が必要な場合
   - **IPC**: ローカルで最速・最もセキュア

   **簡単に言うと**:
   - **HTTP** = 「郵便」（一度質問して、一度返事をもらう）
   - **WebSocket** = 「電話」（つながったまま、リアルタイムで会話）
   - **IPC** = 「内線電話」（同じ建物内だけ、最速・最安全）

   **どれを使う？**
   - 普通の操作 → HTTP（最も簡単）
   - リアルタイム監視 → WebSocket（新しいブロックが来たら通知）
   - 同じPC内での通信 → IPC（最速）

3. **personalモジュールは非推奨**:
   - アカウント作成は`geth account new`を使用
   - Clefやハードウェアウォレットの活用

   **なぜ非推奨？**
   - `personal` API = 「APIで秘密鍵を操作」
   - セキュリティリスクが高い（ネット経由で秘密鍵を扱うのは危険）
   - **代わりに**: コマンドラインで直接操作する方が安全

4. **単位の理解**:
   - 1 ETH = 10¹⁸ Wei
   - ガス価格はGwei（10⁹ Wei）で表示されることが多い

   **簡単に言うと**:
   - **ETH** = 「1万円」（普段使う単位）
   - **Gwei** = 「1円」（ガス代の単位）
   - **Wei** = 「0.01銭」（最小単位、普段は使わない）

   **なぜこんなに小さい単位？**
   - ガス代は「0.000000001 ETH」のように小さな金額
   - Gweiで表すと「1 Gwei」のように分かりやすくなる

5. **バリデータの報酬**:
   - 正しくブロックを提案・証明することで報酬を獲得
   - 残高が少しずつ増加（32.001957509 ETH）

   **簡単に言うと**:
   - **バリデータ** = 「銀行員」
   - **報酬** = 「給料」
   - **なぜ報酬がもらえる？**
     1. ブロックを作る = 「取引を処理する」→ 報酬
     2. 他のブロックを証明する = 「他の銀行員の仕事をチェックする」→ 報酬
     3. ネットワークを守る = 「セキュリティを維持する」→ 報酬

   **報酬の計算**:
   - 開始時: 32 ETH（デポジット）
   - 現在: 32.001957509 ETH
   - 報酬: 0.001957509 ETH（約0.006%の増加）
   - **例**: 銀行預金の金利のようなもの（ただし、仕事をしないともらえない）

## 11. 次のステップ

**これまでの学習**:
- プライベートPoSネットワークの構築 ✅
- JSON-RPC APIの基本操作 ✅
- Beacon Chain APIの使い方 ✅

**次に学ぶこと（2025-12-09）**:
- 4バリデータでのPoS動作確認
- ブロック生成とattestationの確認
- バリデータ報酬の発生と検証

**今後の課題**:
- 実際にETHを送金してみる
- スマートコントラクトを作ってデプロイする
- リアルタイムでブロックチェーンの動きを監視する

### 11.1 推奨される学習内容

1. **トランザクションの送信**:
   - genesis.jsonでアカウントにETHを事前割り当て
   - `eth_sendTransaction`でトランザクション送信
   - ガス代の理解

   **簡単に言うと**:
   - **トランザクション** = 「銀行振込」
   - 今はアカウントの残高が0なので、まずETHを割り当てる必要がある
   - **例**: 銀行口座を作っただけで、まだお金を入れていない状態 → まずお金を入れる

   **学ぶこと**:
   - ETHの送り方
   - ガス代（手数料）の仕組み
   - トランザクションの確認方法

2. **スマートコントラクトのデプロイ**:
   - Solidityでコントラクト作成
   - Remixやハードハットでコンパイル
   - `eth_sendTransaction`でデプロイ

   **簡単に言うと**:
   - **スマートコントラクト** = 「自動販売機のプログラム」
   - お金を入れると自動で商品が出てくる仕組みをブロックチェーンに作る
   - **例**: 「100円入れたらジュースが出る」というルールをプログラムで書く

   **学ぶこと**:
   - Solidityプログラミング言語
   - コントラクトのコンパイル（人間が読める言語 → コンピュータが実行できる形式）
   - ブロックチェーンへのデプロイ方法

3. **イベントのリスニング**:
   - WebSocketでリアルタイム通知
   - `eth_subscribe`で新しいブロックを監視
   - ログのフィルタリング

   **簡単に言うと**:
   - **イベントリスニング** = 「ニュース速報を受け取る」
   - 新しいブロックができたら自動で通知が来る
   - **例**: LINEの通知のようなもの（新しいメッセージが来たら「ピロン」と通知）

   **学ぶこと**:
   - WebSocket接続の仕方
   - リアルタイム監視の実装
   - 特定のイベント（例: 自分のアドレスへの送金）だけをフィルタリング

4. **web3.js/ethers.jsの本格活用**:
   - DAppのフロントエンド開発
   - MetaMaskとの連携
   - コントラクトとのやり取り

   **簡単に言うと**:
   - **DApp** = 「ブロックチェーンを使うWebアプリ」
   - MetaMask = 「ブラウザに入れるウォレット（財布）」
   - **例**: ネットバンキングのアプリのようなもの（Webページでお金を管理）

   **学ぶこと**:
   - React/Vueなどでフロントエンド作成
   - MetaMaskでユーザーの署名を取得
   - スマートコントラクトの関数を呼び出す

5. **Beacon Chain APIの深掘り**:
   - 証明（attestation）の監視
   - スラッシング条件の理解
   - 報酬とペナルティの計算

   **簡単に言うと**:
   - **証明（attestation）** = 「他のバリデータの仕事をチェックして承認する」
   - **スラッシング** = 「不正をしたバリデータへのペナルティ（罰金）」
   - **例**: 銀行員が他の銀行員の仕事をチェック → 問題なければ報酬、不正があれば罰金

   **学ぶこと**:
   - バリデータがどうやってブロックを承認しているか
   - どういう不正をするとペナルティを受けるか
   - 報酬がどうやって計算されるか

### 11.2 参考リソース

- **Geth JSON-RPC API**: https://geth.ethereum.org/docs/interacting-with-geth/rpc
- **Ethereum Beacon APIs**: https://ethereum.github.io/beacon-APIs/
- **web3.js ドキュメント**: https://web3js.readthedocs.io/
- **ethers.js ドキュメント**: https://docs.ethers.org/
- **Ethereum.org - JSON-RPC**: https://ethereum.org/en/developers/docs/apis/json-rpc/

### 11.3 最後に

本学習を通じて、以下を達成しました：

✅ **JSON-RPC APIの基本的な使い方を習得**
✅ **アカウントの作成と管理方法を理解**
✅ **ブロックチェーン情報の取得方法を実践**
✅ **Beacon Chain API（PoS特有）の使用方法を学習**
✅ **実用的なスクリプトの作成**

**簡単に言うと、できるようになったこと**:
- ブロックチェーンに「質問」して「答え」をもらえるようになった
- アカウント（銀行口座）を作れるようになった
- ブロックチェーンの状態（残高、ブロック番号など）を確認できるようになった
- バリデータの働きを監視できるようになった
- 便利なスクリプトを書けるようになった

**PoS vs PoWの違い**:
- PoW（Proof of Work）では、マイナー情報のみ
- **PoS（Proof of Stake）では、バリデータ情報、証明、スロット/エポック等の追加情報**

**簡単に言うと**:
- **PoW（古い方式）** = 「計算問題を解いた人がブロックを作る」
  - マイナー = 「計算する人」
  - APIで見られる情報: マイナーのアドレス、ハッシュレート

- **PoS（新しい方式）** = 「ETHを預けた人がブロックを作る」
  - バリデータ = 「ETHを預けた人」
  - APIで見られる情報: バリデータの残高、証明、スロット、エポック、報酬

本学習で構築したプライベートPoSネットワークは、まさに**本番のEthereum Mainnetと同じアーキテクチャ**です。

**これの何がすごい？**
- 本番のEthereumと全く同じ仕組み
- ただし、お金は本物ではない（練習用）
- 失敗しても大丈夫（本物のお金は失わない）
- **例**: 本物の飛行機と同じ操作ができるフライトシミュレーター

**学習の流れ**:
1. **2025-12-03〜04**: PoSネットワークの構築（Geth + Prysm）
2. **2025-12-08**: JSON-RPC APIとBeacon Chain APIの実践（本学習）
3. **2025-12-09**: 4バリデータでのPoS動作確認と報酬検証
4. **今後の課題**: トランザクション送信とスマートコントラクトデプロイ

**初心者向けの説明**:
1. **ステップ1**: ブロックチェーンのネットワークを自分のPCに作った
2. **ステップ2（今日）**: そのネットワークとお話しする方法を学んだ
3. **ステップ3（2025-12-09）**: 4人のバリデータで実際にPoSを動かして、報酬をもらう仕組みを確認する
4. **ステップ4（今後）**: 実際にお金を送ったり、プログラムをデプロイしたりする

この知識は、DApp開発、ブロックチェーンエンジニアリング、そしてWeb3エコシステム全体の理解に直結します。実際にAPIを叩いて、ブロックチェーンと対話する体験は、書籍やチュートリアルだけでは得られない貴重な学びです。

**なぜこれが重要？**
- **DApp開発**: Webアプリがブロックチェーンとやり取りする基礎
- **ブロックチェーンエンジニアリング**: 裏側の仕組みを理解できる
- **Web3エコシステム**: 分散型アプリの世界を理解できる

**本だけではダメ？**
- 本で読むだけ = 「泳ぎ方の本を読む」
- 実際にやる = 「実際にプールで泳ぐ」
- 本で学んだことを実践することで、初めて本当に理解できる

引き続き、トランザクションの送信やスマートコントラクトのデプロイに挑戦し、実践的なDApp開発へと進んでいきましょう！
